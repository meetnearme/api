package pages

import (
	"context"
	"github.com/meetnearme/api/functions/gateway/constants"
	"github.com/meetnearme/api/functions/gateway/templates/components"
	"os"
	"strconv"
	"strings"
)

func extractMnmOptions(mnmOptions string) map[string]string {
	mnmOptionsMap := map[string]string{}
	parts := strings.Split(mnmOptions, ";")
	for _, part := range parts {
		parts := strings.Split(part, "=")
		if len(parts) == 2 {
			mnmOptionsMap[parts[0]] = parts[1]
		}
	}
	return mnmOptionsMap
}

func getEventsAdminUrl(userInfo constants.UserInfo) string {
	return "/api/html/events?list_mode=" + constants.EV_MODE_ADMIN_LIST + "&radius=" + strconv.Itoa(constants.DEFAULT_MAX_RADIUS) + "&start_time=1971-01-01T10:00:00Z&end_time=2099-10-18T10:00:00Z&owners=" + userInfo.Sub + "&event_source_types=" + constants.ES_SINGLE_EVENT + "," + constants.ES_SINGLE_EVENT_UNPUB + "," + constants.ES_SERIES_PARENT + "," + constants.ES_SERIES_PARENT_UNPUB
}

func getCompetitionsAdminUrl(userInfo constants.UserInfo) string {
	return "/api/html/competition-config/owner/" + userInfo.Sub
}

func getProfileInterestsAdminUrl() string {
	return "/api/html/profile-interests"
}

func getSubscriptionsAdminUrl() string {
	return "/api/html/subscriptions"
}

templ AdminPage(userInfo constants.UserInfo, roleClaims []constants.RoleClaim, interests []string, userSubdomain, mnmOptions, userAbout string, ctx context.Context) {
	<h1 class="text-3xl">Admin</h1>
	<br/>
	<br/>
	<div id="admin-content-container" class="md:grid md:grid-cols-7" x-data="getAdminState()">
		@components.AdminNav(ctx)
		<div class="htmx-show-in-flight col-span-5 card border-2 border-base-300 bg-base-100 p-10 rounded-box">
			<template x-for="i in Array.from({length: 3}, (_, i) => i)" :key="i">
				<table class="table top-align bg-base-100 table-pin-rows table-pin-cols table-zebra">
					<tr class="border-t-2 border-base-300">
						<td><div class="skeleton h-4 w-full"></div></td>
						<td colspan="6">
							<div class="flex w-full flex-col gap-4">
								<div class="skeleton h-4 w-full"></div>
								<div class="skeleton h-4 w-1/2"></div>
								<div class="skeleton h-4 w-full"></div>
							</div>
						</td>
						<td><div class="skeleton h-4 w-full"></div></td>
						<td>
							<div class="skeleton h-4 w-full"></div>
						</td>
					</tr>
				</table>
			</template>
		</div>
		<div
			id="admin-content"
			class="htmx-hide-in-flight col-span-5 card border-2 border-base-300 bg-base-100 p-10 rounded-box"
		>
			<template x-if="newRole && !roleResolved">
				<div class="alert alert-info mb-4">
					<span class="candidates-loading-visible loading loading-ball loading-lg h-auto"></span>
					<span>Checking your subscription status...</span>
				</div>
			</template>
			<h2 id="registration-history" class="text-2xl font-bold mt-4">Event Purchases &amp; Registrations</h2>
			<div>
				<template x-if="purchasesNextCursor">
					<a class="btn btn-sm float-end" :href=" window.location.pathname + '?purch_start_key=' + purchasesNextCursor">Show Next &rarr;</a>
				</template>
				<table class="table top-align bg-base-100 table-pin-rows table-pin-cols table-zebra">
					<thead>
						<tr>
							<th>Status</th>
							<th colspan="6">Purchase Type(s)</th>
							<th>Total</th>
							<th>Signup Time</th>
						</tr>
					</thead>
					<template x-if="!hasPurchasesResults">
						<template x-for="i in Array.from({length: 3}, (_, i) => i)" :key="i">
							<tr class="border-t-2 border-base-300">
								<td><div class="skeleton h-4 w-full"></div></td>
								<td colspan="6">
									<div class="flex w-full flex-col gap-4">
										<div class="skeleton h-4 w-full"></div>
										<div class="skeleton h-4 w-1/2"></div>
										<div class="skeleton h-4 w-full"></div>
									</div>
								</td>
								<td><div class="skeleton h-4 w-full"></div></td>
								<td>
									<div class="skeleton h-4 w-full"></div>
								</td>
							</tr>
						</template>
					</template>
					<tbody>
						<template x-if="hasPurchasesResults && purchases.length > 0">
							<template x-for="purchase in purchases" :key="purchase.composite_key">
								<tr
									class="border-t-2 border-base-300"
									:class="{ 'border-l-2 border-primary': newKeyId === purchase.composite_key }"
									:data-purch-key="purchase.composite_key"
								>
									<td x-text="getPurchaseStatus(purchase)"></td>
									<td colspan="6">
										<a class="link link-primary" :href="`/event/${purchase.event_id}`" x-text="purchase.event_name"></a>
										<template x-for="(item, idx) in purchase.purchased_items" :key="item.name">
											<div>
												<template x-if="idx >= 1">
													<div class="divider"></div>
												</template>
												<div x-text="item.name"></div>
												<div x-text="'Quantity: ' + item.quantity"></div>
												<div>
													<td x-text="`${item.cost > 0 ? '$' + (item.cost / 100).toFixed(2) : 'Free'}`"></td>
													<span x-text="item.currency"></span>
												</div>
												<div x-show="item.reg_responses && item.reg_responses.length > 0">
													<h2 class="text-md mt-2">Registration Responses</h2>
													<div class="card bg-base-100 px-4 py-2 my-2">
														<template x-for="(response, index) in item.reg_responses" :key="index">
															<div>
																<template x-if="index >= 1">
																	<div class="divider my-1"></div>
																</template>
																<template x-for="(value, key) in response" :key="key">
																	<div>
																		<span class="font-medium font-bold" x-text="key + ': '"></span>
																		<span x-text="value"></span>
																	</div>
																</template>
															</div>
														</template>
													</div>
												</div>
											</div>
										</template>
									</td>
									<td x-text="`${purchase.total > 0 ? '$' + (purchase.total / 100).toFixed(2) : 'Free'}`"></td>
									<td x-text="new Date(purchase.created_at * 1000).toLocaleString()"></td>
								</tr>
							</template>
						</template>
					</tbody>
					<tfoot>
						<tr>
							<th>Status</th>
							<th colspan="6">Purchase Type(s)</th>
							<th>Total</th>
							<th>Time</th>
						</tr>
					</tfoot>
				</table>
			</div>
			<h2 class="text-2xl font-bold ">User Info</h2>
			Name: { userInfo.Name }
			<br/>
			Email: { userInfo.Email }
			<br/>
			Email Verified:
			if userInfo.EmailVerified {
				Yes
			} else {
				No
			}
			<br/>
			User ID: { userInfo.Sub }
			<br/>
			<br/>
			<h3 id="roles-section" class="text-2xl font-bold scroll-margin-top">Subscriptions</h3>
			<template x-if="newRole && roleResolved && !roleFound">
				<div class="alert alert-warning mb-4">
					@components.Icon("triangle-alert")
					<span>Your subscription is being processed. If you need assistance, please reach out via <a class="link link-primary" href="https://discord.gg/zfXWhGHs8T">Discord</a> or <a class="link link-primary" href="mailto:info@meetnear.me">email</a>.</span>
				</div>
			</template>
			<template x-if="newRole && roleResolved && roleFound">
				<div class="alert alert-success mb-4">
					@components.Icon("check-circle")
					<span>Your subscription is now active!</span>
				</div>
			</template>
			<template x-if="roleResolved && roleFound">
				<div class="flex flex-wrap space-x-4 mb-4 gap-2">
					for _, roleClaim := range roleClaims {
						<span class="badge badge-lg badge-primary whitespace-nowrap">
							if roleClaim.Role == string(constants.SubGrowth) {
								Growth Community
							} else if roleClaim.Role == string(constants.SubSeed) {
								Seed Community
							} else {
								{ roleClaim.Role }
							}
						</span>
						<br/>
					}
				</div>
			</template>
			<h3 class="text-2xl font-bold">Interests</h3>
			if len(interests) > 1 {
				<div class="mb-4">
					<ul>
						for _, interest := range interests {
							<li>
								- { interest }
							</li>
						}
					</ul>
				</div>
			}
			<p class="mb-4">Set your interests on the <a class="text-primary" href="/admin/interests">interests page</a>.</p>
			<h3 class="text-2xl font-bold mb-4">Subdomain</h3>
			{{ baseDomain := strings.TrimPrefix(os.Getenv("APEX_URL"), "https://") }}
			<div
				x-data={ `{
				subdomainPreview: '` + userSubdomain + `',
				subdomain: '` + userSubdomain + `',
				baseDomain: '` + baseDomain + `',
				handleSubdomainPostRes(event) {
					if (event.detail.successful) {
						this.subdomainPreview = this.subdomain;
					}
				}
			}` }
			>
				<p class="mb-4">
					View custom subdomain at
					<a
						class="link link-primary"
						x-bind:href=" 'https://' + subdomainPreview + '.' + baseDomain "
						x-text=" 'https://' + subdomainPreview + '.' + baseDomain "
					></a>
				</p>
				<form
					class="group"
					novalidate
					hx-post="/api/auth/users/update-mnm-options"
					hx-ext="json-enc"
					hx-target="#subdomain-result"
					hx-disabled-elt="button[type='submit']"
					@submit.prevent=""
					@htmx:after-request="handleSubdomainPostRes(event)"
					hx-vals="js:{...getMnmOptionsPayload()}"
				>
					<input
						id="subdomain"
						if userSubdomain != "" {
							value={ userSubdomain }
						}
						x-model="subdomain"
						pattern="[a-z0-9]+"
						:class="{ 'input-error': subdomain && !subdomain.match(/^[a-z0-9\-]+$/) }"
						name="subdomain"
						type="text"
						class="input input-bordered w-full"
					/>
					<div x-show="subdomain && !subdomain.match(/^[a-z0-9\-]+$/)" class="text-error text-sm mt-1">
						Subdomain must contain only lowercase letters and numbers and/or hyphens
					</div>
					<button type="submit" class="btn btn-primary mt-4">Update Subdomain<span class="htmx-indicator loading loading-spinner loading-sm"></span></button>
				</form>
				<div id="subdomain-result" class="margins-when-children my-8"></div>
				<h3 class="text-2xl font-bold mb-4 mt-4">Custom Theme</h3>
				<p>
					Your subdomain will use the theme colors you choose below.
					<div class="mx-auto w-full max-w-xl">
						<form
							class="group"
							novalidate
							hx-post="/api/auth/users/update-mnm-options?theme=1"
							hx-ext="json-enc"
							hx-target="#theme-result"
							hx-disabled-elt="button[type='submit']"
							@submit.prevent=""
							@htmx:after-request="handleSubdomainPostRes(event)"
							hx-vals="js:{...getMnmOptionsPayload()}"
						>
							{{ primaryColor := extractMnmOptions(mnmOptions)["--p"] }}
							@components.ColorPicker(primaryColor, "Primary Brand Color", "primary-color-picker-input")
							<h4 class="text-lg font-bold mt-2">Theme Mode</h4>
							<!-- END Input -->
							// switch toggle for light / vs dark theme
							{{ themeModeLight := extractMnmOptions(mnmOptions)["themeMode"] == "light" }}
							<div x-data={ `{ themeModeLight: ` + strconv.FormatBool(themeModeLight) + ` }` } class="form-control">
								<label class="label cursor-pointer">
									<span class="label-text" x-text="themeModeLight ? 'Light Theme' : 'Dark Theme' "></span>
									<input
										id="theme-mode"
										type="checkbox"
										class="toggle toggle-primary"
										x-model="themeModeLight"
									/>
								</label>
							</div>
							<button type="submit" class="btn btn-primary mt-4">Update Theme<span class="htmx-indicator loading loading-spinner loading-sm"></span></button>
						</form>
					</div>
				</p>
			</div>
			<div id="theme-result" class="margins-when-children my-8"></div>
			<h3 class="text-2xl font-bold mb-4 mt-4">About / Bio</h3>
			<form
				class="group"
				novalidate
				hx-post="/api/auth/users/update-about"
				hx-ext="json-enc"
				hx-target="#about-result"
				hx-disabled-elt="button[type='submit']"
				@submit.prevent=""
			>
				<div class="form-control">
					<label class="label" for="description">Description</label>
					<textarea
						name="about"
						class="textarea textarea-bordered w-full"
						maxlength="750"
						id="about"
						placeholder="Personal bio or organization description on your profile"
					>
						{ userAbout }
					</textarea>
				</div>
				<button type="submit" class="btn btn-primary mt-4">Update About<span class="htmx-indicator loading loading-spinner loading-sm"></span></button>
			</form>
			<div id="about-result" class="margins-when-children my-8"></div>
		</div>
	</div>
	<script id="admin-state" data-user-id={ userInfo.Sub } data-status-pending={ constants.PurchaseStatus.Pending } data-status-settled={ constants.PurchaseStatus.Settled } data-role-not-found-message={ constants.ROLE_NOT_FOUND_MESSAGE } data-events-url={ getEventsAdminUrl(userInfo) } data-competitions-url={ getCompetitionsAdminUrl(userInfo) } data-profile-interests-url={ getProfileInterestsAdminUrl() } data-subscriptions-url={ getSubscriptionsAdminUrl() }>
		// Admin sub-routing with Navigation API
		(function() {
			const adminStateEl = document.querySelector('#admin-state');
			if (!adminStateEl) return;

			// Route mapping for admin sub-pages
			const adminRoutes = {
				'/admin/events': {
					url: adminStateEl.getAttribute('data-events-url'),
					title: 'Admin - Events'
				},
				'/admin/competitions': {
					url: adminStateEl.getAttribute('data-competitions-url'),
					title: 'Admin - Competitions'
				},
				'/admin/interests': {
					url: adminStateEl.getAttribute('data-profile-interests-url'),
					title: 'Admin - Interests'
				},
				'/admin/subscriptions': {
					url: adminStateEl.getAttribute('data-subscriptions-url'),
					title: 'Admin - Subscriptions'
				}
			};

			// Handle direct navigation (browser back/forward or direct URL access)
			function handleAdminRoute(event) {
				const url = event ? (event.destination?.url || window.location.href) : window.location.href;
				const path = new URL(url).pathname;

				const route = adminRoutes[path];
				if (!route) return; // Not an admin sub-route

				const adminContent = document.getElementById('admin-content');
				if (!adminContent) return;

				// Update page title
				if (route.title) {
					document.title = route.title;
				}

				// Load content via HTMX
				if (window.htmx) {
					// eslint-disable-next-line no-undef
					htmx.ajax('GET', route.url, {
						target: '#admin-content',
						swap: 'innerHTML'
					});
				} else {
					// Fallback if HTMX not ready
					fetch(route.url)
						.then(res => res.text())
						.then(html => {
							adminContent.innerHTML = html;
						})
						.catch(err => {
							// eslint-disable-next-line no-console
							console.error('Failed to load admin route:', err);
						});
				}
			}

			if (!window.navigation) {
				// Navigation API not supported, fallback to popstate
				window.addEventListener('popstate', handleAdminRoute);
				// Handle initial load if on a sub-route
				if (adminRoutes[window.location.pathname]) {
					if (document.readyState === 'loading') {
						document.addEventListener('DOMContentLoaded', () => handleAdminRoute());
					} else {
						handleAdminRoute();
					}
				}
				return;
			}

			// Track when HTMX is handling navigation to prevent double-firing
			let htmxIsNavigating = false;
			let htmxNavigationTimeout = null;

			// Listen to HTMX events to track when it's handling a navigation with hx-push-url
			if (window.htmx) {
				// Mark when HTMX starts a request that will push URL
				document.body.addEventListener('htmx:beforeRequest', function(event) {
					const el = event.detail.elt;
					if (el && el.hasAttribute('hx-push-url')) {
						htmxIsNavigating = true;
						// Clear any existing timeout
						if (htmxNavigationTimeout) {
							clearTimeout(htmxNavigationTimeout);
						}
					}
				});

				// Clear the flag after HTMX completes and URL push has time to happen
				document.body.addEventListener('htmx:afterSwap', function() {
					// Give enough time for hx-push-url to trigger Navigation API
					htmxNavigationTimeout = setTimeout(() => {
						htmxIsNavigating = false;
					}, 200);
				});

				// Also clear on error
				document.body.addEventListener('htmx:responseError', function() {
					if (htmxNavigationTimeout) {
						clearTimeout(htmxNavigationTimeout);
					}
					htmxIsNavigating = false;
				});
			}

			// Listen for navigate events (Navigation API)
			// Only intercept navigations that are NOT HTMX-initiated
			window.navigation.addEventListener('navigate', (event) => {
				const url = new URL(event.destination.url);
				if (url.pathname.startsWith('/admin/') && adminRoutes[url.pathname]) {
					// Skip if HTMX is currently handling this navigation
					if (htmxIsNavigating) {
						return;
					}

					// Check if this navigation was triggered by an HTMX link
					const sourceElement = event.sourceElement;
					const isFromHtmxLink = sourceElement && (
						sourceElement.hasAttribute('hx-get') ||
						sourceElement.hasAttribute('hx-post') ||
						sourceElement.hasAttribute('hx-push-url')
					);

					// Skip HTMX-initiated navigations - let HTMX handle them
					if (isFromHtmxLink) {
						return;
					}

					// Only intercept browser-initiated navigations:
					// - traverse: back/forward buttons
					// - reload: page refresh
					// - push/replace: programmatic navigations (not from HTMX)
					if (event.navigationType === 'traverse' || event.navigationType === 'reload') {
						event.intercept({
							handler() {
								handleAdminRoute(event);
							}
						});
					} else if ((event.navigationType === 'push' || event.navigationType === 'replace') && !isFromHtmxLink) {
						// Only intercept programmatic navigations that aren't from HTMX
						event.intercept({
							handler() {
								handleAdminRoute(event);
							}
						});
					}
				}
			});

			// Handle initial load if on a sub-route
			if (adminRoutes[window.location.pathname]) {
				// Wait for page to be fully loaded
				if (document.readyState === 'loading') {
					document.addEventListener('DOMContentLoaded', () => handleAdminRoute());
				} else {
					handleAdminRoute();
				}
			}
		})();

		// eslint-disable-next-line no-unused-vars
		function getMnmOptionsPayload() {
			const payload = {
				subdomain: document.getElementById('subdomain')?.value ?? '',
				primaryColor: document.getElementById('primary-color-picker-input')?.value ?? '',
				themeMode: document.getElementById('theme-mode')?.checked ? 'light' : 'dark',
			}
			return payload;
		}
		function getAdminState() {
			return {
				init() {
					(async () => {
						window.location.href.match('#')
						let searchQuery = window.location.hash.split('?')[1] || '';
						if (!window.location.href.match('#')) {
							searchQuery = window.location.search
						}
						this.newKeyId = new URLSearchParams(searchQuery).get('new_purch_key');
						this.newRole = new URLSearchParams(searchQuery).get('new_role');
						const promises = [];

						// Poll for role if new_role param is present
						if (this.newRole) {
							promises.push(this.pollForRole());
						}
						// Otherwise, render roles immediately
						else {
							this.roleResolved = true;
							this.roleFound = true;
						}

						const fetchPurchases = async () => {
							const startKey = new URLSearchParams(window.location.search).get('purch_start_key') ?? '';
							const reqUrl = `/api/purchases/user/${this.userId}${ startKey ? `?start_key=${encodeURIComponent(startKey)}` : '' }`;
							const purchasesResponse = await fetch(reqUrl);
							const purchasesResData = await purchasesResponse.json();
							this.purchases = purchasesResData.purchases ?? [];
							this.purchasesNextCursor = purchasesResData?.nextKey?.compositeKey?.Value;
							this.hasPurchasesResults = true;
						};

						const pollPurchases = async () => {
							const maxAttempts = 10;
							const delayMs = 250;
							let attempts = 0;
							try {
								await fetchPurchases();

								// If we're not looking for a specific purchase, or if we found it, stop polling
								if (!this.newKeyId || this.purchases.some(p => p.composite_key === this.newKeyId)) {
									if (this.purchases.some(p => p.composite_key === this.newKeyId)) {
										const purchaseRow = document.querySelector(`[data-purch-key="${this.newKeyId}"]`);
										if (purchaseRow) {
											purchaseRow.scrollIntoView({ behavior: 'smooth', block: 'start', inline: 'start' });
										}
									}
									return;
								}

								// Continue polling if we haven't reached max attempts
								if (attempts < maxAttempts) {
									attempts++;
									await new Promise(resolve => setTimeout(resolve, delayMs));
									await pollPurchases();
								}
							} catch (error) {
								// eslint-disable-next-line no-console
								console.error('Failed to fetch purchases:', error);
							}
						};

						promises.push(pollPurchases());

						await Promise.all(promises);
					})()
				},
				newKeyId: null,
				newRole: null,
				purchases: [],
				hasPurchasesResults: false,
				roleResolved: false,
				roleFound: false,
				purchasesNextCursor: null,
				userId: document.querySelector('#admin-state').getAttribute('data-user-id'),
				statusPending: document.querySelector('#admin-state').getAttribute('data-status-pending'),
				statusSettled: document.querySelector('#admin-state').getAttribute('data-status-settled'),
				roleNotFoundMessage: document.querySelector('#admin-state').getAttribute('data-role-not-found-message'),
				async pollForRole() {
					const delays = [500, 1500, 5000]; // Poll at 500ms, 1.5s, and 5s

					for (const delay of delays) {
						await new Promise(resolve => setTimeout(resolve, delay));

						try {
							// First refresh the auth token to get latest claims
							await fetch('/auth/refresh');

							// Then check if role is present
							const response = await fetch(`/api/auth/check-role?role=${encodeURIComponent(this.newRole)}`);
							const jsonResponse = await response.json();
							// Check if the HTML content indicates role not found
							if (jsonResponse.error && jsonResponse.error.message.includes(this.roleNotFoundMessage)) {
								// Role not found yet, continue polling - this is expected
								// eslint-disable-next-line no-console
								console.log(`Role ${this.newRole} not found yet, continuing to poll...`);
								continue;
							}

							// Role found! Display the success message
							const rolesSection = document.querySelector('#roles-section');
							rolesSection.scrollIntoView({ behavior: 'smooth', block: 'start', inline: 'start' });
							// Role found, stop pollging
							this.roleResolved = true;
							this.roleFound = true;
							return;
						} catch (error) {
							// eslint-disable-next-line no-console
							console.error('Failed to check role:', error);
							this.roleResolved = true;
							this.roleFound = false;
						}
					}

					// If we've exhausted all retries, show a message to refresh manually
					this.roleResolved = true;
					this.roleFound = false;
				},
				getPurchasesNextLink() {
					return window.location.href + '?purch_start_key=' + this.purchasesNextCursor + '_' + this.userId;
				},
				// handleSubdomainPostRes: function(event) {
				// 	// eslint-disable-next-line no-console
				// 	console.log(event)
				// },
				getPurchaseStatus(purchase) {
					return purchase.status.replace(this.statusSettled, 'PAID').replace(this.statusPending, 'INCOMPLETE')
				}
			}
		}
	</script>
}
