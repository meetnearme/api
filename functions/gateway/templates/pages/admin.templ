package pages

import (
	"context"
	"github.com/meetnearme/api/functions/gateway/constants"
	"github.com/meetnearme/api/functions/gateway/templates/components"
	"os"
	"strconv"
	"strings"
)

func extractMnmOptions(mnmOptions string) map[string]string {
	mnmOptionsMap := map[string]string{}
	parts := strings.Split(mnmOptions, ";")
	for _, part := range parts {
		parts := strings.Split(part, "=")
		if len(parts) == 2 {
			mnmOptionsMap[parts[0]] = parts[1]
		}
	}
	return mnmOptionsMap
}

func getEventsAdminUrl(userInfo constants.UserInfo) string {
	return "/api/html/events?list_mode=" + constants.EV_MODE_ADMIN_LIST + "&radius=" + strconv.Itoa(constants.DEFAULT_MAX_RADIUS) + "&start_time=1971-01-01T10:00:00Z&end_time=2099-10-18T10:00:00Z&owners=" + userInfo.Sub + "&event_source_types=" + constants.ES_SINGLE_EVENT + "," + constants.ES_SINGLE_EVENT_UNPUB + "," + constants.ES_SERIES_PARENT + "," + constants.ES_SERIES_PARENT_UNPUB
}

func getCompetitionsAdminUrl(userInfo constants.UserInfo) string {
	return "/api/html/competition-config/owner/" + userInfo.Sub
}

func getProfileInterestsAdminUrl() string {
	return "/api/html/profile-interests"
}

func getSubscriptionsAdminUrl() string {
	return "/api/html/subscriptions"
}

templ AdminPage(userInfo constants.UserInfo, roleClaims []constants.RoleClaim, interests []string, userSubdomain, mnmOptions, userAbout string, ctx context.Context) {
	<div class="max-w-screen-2xl mx-auto px-4 py-4">
		<h1 class="text-3xl mb-6">Admin</h1>
		<br/>
		<br/>
		<div id="admin-content-container" class="md:grid md:grid-cols-7 gap-4" x-data="getAdminState()">
			@components.AdminNav(ctx)
			<div class="htmx-show-in-flight col-span-5 card border-2 border-base-300 bg-base-100 p-10 rounded-box">
				<template x-for="i in Array.from({length: 3}, (_, i) => i)" :key="i">
					<table class="table top-align bg-base-100 table-pin-rows table-pin-cols table-zebra">
						<tr class="border-t-2 border-base-300">
							<td><div class="skeleton h-4 w-full"></div></td>
							<td colspan="6">
								<div class="flex w-full flex-col gap-4">
									<div class="skeleton h-4 w-full"></div>
									<div class="skeleton h-4 w-1/2"></div>
									<div class="skeleton h-4 w-full"></div>
								</div>
							</td>
							<td><div class="skeleton h-4 w-full"></div></td>
							<td>
								<div class="skeleton h-4 w-full"></div>
							</td>
						</tr>
					</table>
				</template>
			</div>
			<div
				id="admin-content"
				class="htmx-hide-in-flight col-span-5 card border-2 border-base-300 bg-base-100 p-10 rounded-box"
			>
				<template x-if="newRole && !roleResolved">
					<div class="alert alert-info mb-4">
						<span class="candidates-loading-visible loading loading-ball loading-lg h-auto"></span>
						<span>Checking your subscription status...</span>
					</div>
				</template>
				<h2 id="registration-history" class="text-2xl font-bold mt-4">Event Purchases &amp; Registrations</h2>
				<div>
					<template x-if="purchasesNextCursor">
						<a class="btn btn-sm float-end" :href=" window.location.pathname + '?purch_start_key=' + purchasesNextCursor">Show Next &rarr;</a>
					</template>
					<table class="table top-align bg-base-100 table-pin-rows table-pin-cols table-zebra">
						<thead>
							<tr>
								<th>Status</th>
								<th colspan="6">Purchase Type(s)</th>
								<th>Total</th>
								<th>Signup Time</th>
							</tr>
						</thead>
						<template x-if="!hasPurchasesResults">
							<template x-for="i in Array.from({length: 3}, (_, i) => i)" :key="i">
								<tr class="border-t-2 border-base-300">
									<td><div class="skeleton h-4 w-full"></div></td>
									<td colspan="6">
										<div class="flex w-full flex-col gap-4">
											<div class="skeleton h-4 w-full"></div>
											<div class="skeleton h-4 w-1/2"></div>
											<div class="skeleton h-4 w-full"></div>
										</div>
									</td>
									<td><div class="skeleton h-4 w-full"></div></td>
									<td>
										<div class="skeleton h-4 w-full"></div>
									</td>
								</tr>
							</template>
						</template>
						<tbody>
							<template x-if="hasPurchasesResults && purchases.length > 0">
								<template x-for="purchase in purchases" :key="purchase.composite_key">
									<tr
										class="border-t-2 border-base-300"
										:class="{ 'border-l-2 border-primary': newKeyId === purchase.composite_key }"
										:data-purch-key="purchase.composite_key"
									>
										<td x-text="getPurchaseStatus(purchase)"></td>
										<td colspan="6">
											<a class="link link-primary" :href="`/event/${purchase.event_id}`" x-text="purchase.event_name"></a>
											<template x-for="(item, idx) in purchase.purchased_items" :key="item.name">
												<div>
													<template x-if="idx >= 1">
														<div class="divider"></div>
													</template>
													<div x-text="item.name"></div>
													<div x-text="'Quantity: ' + item.quantity"></div>
													<div>
														<td x-text="`${item.cost > 0 ? '$' + (item.cost / 100).toFixed(2) : 'Free'}`"></td>
														<span x-text="item.currency"></span>
													</div>
													<div x-show="item.reg_responses && item.reg_responses.length > 0">
														<h2 class="text-md mt-2">Registration Responses</h2>
														<div class="card bg-base-100 px-4 py-2 my-2">
															<template x-for="(response, index) in item.reg_responses" :key="index">
																<div>
																	<template x-if="index >= 1">
																		<div class="divider my-1"></div>
																	</template>
																	<template x-for="(value, key) in response" :key="key">
																		<div>
																			<span class="font-medium font-bold" x-text="key + ': '"></span>
																			<span x-text="value"></span>
																		</div>
																	</template>
																</div>
															</template>
														</div>
													</div>
												</div>
											</template>
										</td>
										<td x-text="`${purchase.total > 0 ? '$' + (purchase.total / 100).toFixed(2) : 'Free'}`"></td>
										<td x-text="new Date(purchase.created_at * 1000).toLocaleString()"></td>
									</tr>
								</template>
							</template>
						</tbody>
						<tfoot>
							<tr>
								<th>Status</th>
								<th colspan="6">Purchase Type(s)</th>
								<th>Total</th>
								<th>Time</th>
							</tr>
						</tfoot>
					</table>
				</div>
				<h2 class="text-2xl font-bold ">User Info</h2>
				Name: { userInfo.Name }
				<br/>
				Email: { userInfo.Email }
				<br/>
				Email Verified:
				if userInfo.EmailVerified {
					Yes
				} else {
					No
				}
				<br/>
				User ID: { userInfo.Sub }
				<br/>
				<br/>
				<h3 id="roles-section" class="text-2xl font-bold scroll-margin-top">Subscriptions</h3>
				<template x-if="newRole && roleResolved && !roleFound">
					<div class="alert alert-warning mb-4">
						@components.Icon("triangle-alert")
						<span>Your subscription is being processed. If you need assistance, please reach out via <a class="link link-primary" href="https://discord.gg/zfXWhGHs8T">Discord</a> or <a class="link link-primary" href="mailto:info@meetnear.me">email</a>.</span>
					</div>
				</template>
				<template x-if="newRole && roleResolved && roleFound">
					<div class="alert alert-success mb-4">
						@components.Icon("check-circle")
						<span>Your subscription is now active!</span>
					</div>
				</template>
				<template x-if="roleResolved && roleFound">
					<div class="flex flex-wrap space-x-4 mb-4 gap-2">
						for _, roleClaim := range roleClaims {
							<span class="badge badge-lg badge-primary whitespace-nowrap">
								if roleClaim.Role == string(constants.SubGrowth) {
									Growth Community
								} else if roleClaim.Role == string(constants.SubSeed) {
									Seed Community
								} else {
									{ roleClaim.Role }
								}
							</span>
							<br/>
						}
					</div>
				</template>
				<h3 class="text-2xl font-bold">Interests</h3>
				if len(interests) > 1 {
					<div class="mb-4">
						<ul>
							for _, interest := range interests {
								<li>
									- { interest }
								</li>
							}
						</ul>
					</div>
				}
				<p class="mb-4">Set your interests on the <a class="text-primary" href="/admin/interests">interests page</a>.</p>
				<h3 class="text-2xl font-bold mb-4">Subdomain</h3>
				{{ baseDomain := strings.TrimPrefix(os.Getenv("APEX_URL"), "https://") }}
				<div
					x-data={ `{
				subdomainPreview: '` + userSubdomain + `',
				subdomain: '` + userSubdomain + `',
				baseDomain: '` + baseDomain + `',
				handleSubdomainPostRes(event) {
					if (event.detail.successful) {
						this.subdomainPreview = this.subdomain;
					}
				}
			}` }
				>
					<p class="mb-4">
						View custom subdomain at
						<a
							class="link link-primary"
							x-bind:href=" 'https://' + subdomainPreview + '.' + baseDomain "
							x-text=" 'https://' + subdomainPreview + '.' + baseDomain "
						></a>
					</p>
					<form
						class="group"
						novalidate
						hx-post="/api/auth/users/update-mnm-options"
						hx-ext="json-enc"
						hx-target="#subdomain-result"
						hx-disabled-elt="button[type='submit']"
						@submit.prevent=""
						@htmx:after-request="handleSubdomainPostRes(event)"
						hx-vals="js:{...getMnmOptionsPayload()}"
					>
						<input
							id="subdomain"
							if userSubdomain != "" {
								value={ userSubdomain }
							}
							x-model="subdomain"
							pattern="[a-z0-9]+"
							:class="{ 'input-error': subdomain && !subdomain.match(/^[a-z0-9\-]+$/) }"
							name="subdomain"
							type="text"
							class="input input-bordered w-full"
						/>
						<div x-show="subdomain && !subdomain.match(/^[a-z0-9\-]+$/)" class="text-error text-sm mt-1">
							Subdomain must contain only lowercase letters and numbers and/or hyphens
						</div>
						<button type="submit" class="btn btn-primary mt-4">Update Subdomain<span class="htmx-indicator loading loading-spinner loading-sm"></span></button>
					</form>
					<div id="subdomain-result" class="margins-when-children my-8"></div>
					<h3 class="text-2xl font-bold mb-4 mt-4">Custom Theme</h3>
					<p>
						Your subdomain will use the theme colors you choose below.
						<div class="mx-auto w-full max-w-xl">
							<form
								class="group"
								novalidate
								hx-post="/api/auth/users/update-mnm-options?theme=1"
								hx-ext="json-enc"
								hx-target="#theme-result"
								hx-disabled-elt="button[type='submit']"
								@submit.prevent=""
								@htmx:after-request="handleSubdomainPostRes(event)"
								hx-vals="js:{...getMnmOptionsPayload()}"
							>
								{{ primaryColor := extractMnmOptions(mnmOptions)["--p"] }}
								@components.ColorPicker(primaryColor, "Primary Brand Color", "primary-color-picker-input")
								<h4 class="text-lg font-bold mt-2">Theme Mode</h4>
								<!-- END Input -->
								// switch toggle for light / vs dark theme
								{{ themeModeLight := extractMnmOptions(mnmOptions)["themeMode"] == "light" }}
								<div x-data={ `{ themeModeLight: ` + strconv.FormatBool(themeModeLight) + ` }` } class="form-control">
									<label class="label cursor-pointer">
										<span class="label-text" x-text="themeModeLight ? 'Light Theme' : 'Dark Theme' "></span>
										<input
											id="theme-mode"
											type="checkbox"
											class="toggle toggle-primary"
											x-model="themeModeLight"
										/>
									</label>
								</div>
								<button type="submit" class="btn btn-primary mt-4">Update Theme<span class="htmx-indicator loading loading-spinner loading-sm"></span></button>
							</form>
						</div>
					</p>
				</div>
				<div id="theme-result" class="margins-when-children my-8"></div>
				<h3 class="text-2xl font-bold mb-4 mt-4">About / Bio</h3>
				<form
					class="group"
					novalidate
					hx-post="/api/auth/users/update-about"
					hx-ext="json-enc"
					hx-target="#about-result"
					hx-disabled-elt="button[type='submit']"
					@submit.prevent=""
				>
					<div class="form-control">
						<label class="label" for="description">Description</label>
						<textarea
							name="about"
							class="textarea textarea-bordered w-full"
							maxlength="750"
							id="about"
							placeholder="Personal bio or organization description on your profile"
						>
							{ userAbout }
						</textarea>
					</div>
					<button type="submit" class="btn btn-primary mt-4">Update About<span class="htmx-indicator loading loading-spinner loading-sm"></span></button>
				</form>
				<div id="about-result" class="margins-when-children my-8"></div>
			</div>
		</div>
		<script id="admin-state" data-user-id={ userInfo.Sub } data-status-pending={ constants.PurchaseStatus.Pending } data-status-settled={ constants.PurchaseStatus.Settled } data-role-not-found-message={ constants.ROLE_NOT_FOUND_MESSAGE } data-events-url={ getEventsAdminUrl(userInfo) } data-competitions-url={ getCompetitionsAdminUrl(userInfo) } data-profile-interests-url={ getProfileInterestsAdminUrl() } data-subscriptions-url={ getSubscriptionsAdminUrl() }>
		// Admin sub-routing with Navigation API
		(function() {
			const adminStateEl = document.querySelector('#admin-state');
			if (!adminStateEl) return;

			// Route mapping for admin sub-pages
			const adminRoutes = {
				'/admin/events': {
					url: adminStateEl.getAttribute('data-events-url'),
					title: 'Admin - Events'
				},
				'/admin/competitions': {
					url: adminStateEl.getAttribute('data-competitions-url'),
					title: 'Admin - Competitions'
				},
				'/admin/interests': {
					url: adminStateEl.getAttribute('data-profile-interests-url'),
					title: 'Admin - Interests'
				},
				'/admin/subscriptions': {
					url: adminStateEl.getAttribute('data-subscriptions-url'),
					title: 'Admin - Subscriptions'
				}
			};

			// Handle direct navigation (browser back/forward or direct URL access)
			function handleAdminRoute(event) {
				const url = event ? (event.destination?.url || window.location.href) : window.location.href;
				const path = new URL(url).pathname;

				const route = adminRoutes[path];
				if (!route) return; // Not an admin sub-route

				const adminContent = document.getElementById('admin-content');
				if (!adminContent) return;

				// Update page title
				if (route.title) {
					document.title = route.title;
				}

				// Load content via HTMX
				if (window.htmx) {
					// eslint-disable-next-line no-undef
					htmx.ajax('GET', route.url, {
						target: '#admin-content',
						swap: 'innerHTML'
					});
				} else {
					// Fallback if HTMX not ready
					fetch(route.url)
						.then(res => res.text())
						.then(html => {
							adminContent.innerHTML = html;
						})
						.catch(err => {
							// eslint-disable-next-line no-console
							console.error('Failed to load admin route:', err);
						});
				}
			}

			if (!window.navigation) {
				// Navigation API not supported, fallback to popstate
				window.addEventListener('popstate', handleAdminRoute);
				// Handle initial load if on a sub-route
				if (adminRoutes[window.location.pathname]) {
					if (document.readyState === 'loading') {
						document.addEventListener('DOMContentLoaded', () => handleAdminRoute());
					} else {
						handleAdminRoute();
					}
				}
				return;
			}

			// Track when HTMX is handling navigation to prevent double-firing
			let htmxIsNavigating = false;
			let htmxNavigationTimeout = null;

			// Listen to HTMX events to track when it's handling a navigation with hx-push-url
			if (window.htmx) {
				// Mark when HTMX starts a request that will push URL
				document.body.addEventListener('htmx:beforeRequest', function(event) {
					const el = event.detail.elt;
					if (el && el.hasAttribute('hx-push-url')) {
						htmxIsNavigating = true;
						// Clear any existing timeout
						if (htmxNavigationTimeout) {
							clearTimeout(htmxNavigationTimeout);
						}
					}
				});

				// Clear the flag after HTMX completes and URL push has time to happen
				document.body.addEventListener('htmx:afterSwap', function() {
					// Give enough time for hx-push-url to trigger Navigation API
					htmxNavigationTimeout = setTimeout(() => {
						htmxIsNavigating = false;
					}, 200);
				});

				// Also clear on error
				document.body.addEventListener('htmx:responseError', function() {
					if (htmxNavigationTimeout) {
						clearTimeout(htmxNavigationTimeout);
					}
					htmxIsNavigating = false;
				});
			}

			// Listen for navigate events (Navigation API)
			// Only intercept navigations that are NOT HTMX-initiated
			window.navigation.addEventListener('navigate', (event) => {
				const url = new URL(event.destination.url);
				if (url.pathname.startsWith('/admin/') && adminRoutes[url.pathname]) {
					// Skip if HTMX is currently handling this navigation
					if (htmxIsNavigating) {
						return;
					}

					// Check if this navigation was triggered by an HTMX link
					const sourceElement = event.sourceElement;
					const isFromHtmxLink = sourceElement && (
						sourceElement.hasAttribute('hx-get') ||
						sourceElement.hasAttribute('hx-post') ||
						sourceElement.hasAttribute('hx-push-url')
					);

					// Skip HTMX-initiated navigations - let HTMX handle them
					if (isFromHtmxLink) {
						return;
					}

					// Only intercept browser-initiated navigations:
					// - traverse: back/forward buttons
					// - reload: page refresh
					// - push/replace: programmatic navigations (not from HTMX)
					if (event.navigationType === 'traverse' || event.navigationType === 'reload') {
						event.intercept({
							handler() {
								handleAdminRoute(event);
							}
						});
					} else if ((event.navigationType === 'push' || event.navigationType === 'replace') && !isFromHtmxLink) {
						// Only intercept programmatic navigations that aren't from HTMX
						event.intercept({
							handler() {
								handleAdminRoute(event);
							}
						});
					}
				}
			});

			// Handle initial load if on a sub-route
			if (adminRoutes[window.location.pathname]) {
				// Wait for page to be fully loaded
				if (document.readyState === 'loading') {
					document.addEventListener('DOMContentLoaded', () => handleAdminRoute());
				} else {
					handleAdminRoute();
				}
			}
		})();

		// eslint-disable-next-line no-unused-vars
		function getMnmOptionsPayload() {
			const payload = {
				subdomain: document.getElementById('subdomain')?.value ?? '',
				primaryColor: document.getElementById('primary-color-picker-input')?.value ?? '',
				themeMode: document.getElementById('theme-mode')?.checked ? 'light' : 'dark',
			}
			return payload;
		}
		function getAdminState() {
			return {
				init() {
					(async () => {
						window.location.href.match('#')
						let searchQuery = window.location.hash.split('?')[1] || '';
						if (!window.location.href.match('#')) {
							searchQuery = window.location.search
						}
						this.newKeyId = new URLSearchParams(searchQuery).get('new_purch_key');
						this.newRole = new URLSearchParams(searchQuery).get('new_role');
						const promises = [];

						// Poll for role if new_role param is present
						if (this.newRole) {
							promises.push(this.pollForRole());
						}
						// Otherwise, render roles immediately
						else {
							this.roleResolved = true;
							this.roleFound = true;
						}

						const fetchPurchases = async () => {
							const startKey = new URLSearchParams(window.location.search).get('purch_start_key') ?? '';
							const reqUrl = `/api/purchases/user/${this.userId}${ startKey ? `?start_key=${encodeURIComponent(startKey)}` : '' }`;
							const purchasesResponse = await fetch(reqUrl);
							const purchasesResData = await purchasesResponse.json();
							this.purchases = purchasesResData.purchases ?? [];
							this.purchasesNextCursor = purchasesResData?.nextKey?.compositeKey?.Value;
							this.hasPurchasesResults = true;
						};

						const pollPurchases = async () => {
							const maxAttempts = 10;
							const delayMs = 250;
							let attempts = 0;
							try {
								await fetchPurchases();

								// If we're not looking for a specific purchase, or if we found it, stop polling
								if (!this.newKeyId || this.purchases.some(p => p.composite_key === this.newKeyId)) {
									if (this.purchases.some(p => p.composite_key === this.newKeyId)) {
										const purchaseRow = document.querySelector(`[data-purch-key="${this.newKeyId}"]`);
										if (purchaseRow) {
											purchaseRow.scrollIntoView({ behavior: 'smooth', block: 'start', inline: 'start' });
										}
									}
									return;
								}

								// Continue polling if we haven't reached max attempts
								if (attempts < maxAttempts) {
									attempts++;
									await new Promise(resolve => setTimeout(resolve, delayMs));
									await pollPurchases();
								}
							} catch (error) {
								// eslint-disable-next-line no-console
								console.error('Failed to fetch purchases:', error);
							}
						};

						promises.push(pollPurchases());

						await Promise.all(promises);
					})()
				},
				newKeyId: null,
				newRole: null,
				purchases: [],
				hasPurchasesResults: false,
				roleResolved: false,
				roleFound: false,
				purchasesNextCursor: null,
				userId: document.querySelector('#admin-state').getAttribute('data-user-id'),
				statusPending: document.querySelector('#admin-state').getAttribute('data-status-pending'),
				statusSettled: document.querySelector('#admin-state').getAttribute('data-status-settled'),
				roleNotFoundMessage: document.querySelector('#admin-state').getAttribute('data-role-not-found-message'),
				async pollForRole() {
					const delays = [500, 1500, 5000]; // Poll at 500ms, 1.5s, and 5s

					for (const delay of delays) {
						await new Promise(resolve => setTimeout(resolve, delay));

						try {
							// First refresh the auth token to get latest claims
							await fetch('/auth/refresh');

							// Then check if role is present
							const response = await fetch(`/api/auth/check-role?role=${encodeURIComponent(this.newRole)}`);
							const jsonResponse = await response.json();
							// Check if the HTML content indicates role not found
							if (jsonResponse.error && jsonResponse.error.message.includes(this.roleNotFoundMessage)) {
								// Role not found yet, continue polling - this is expected
								// eslint-disable-next-line no-console
								console.log(`Role ${this.newRole} not found yet, continuing to poll...`);
								continue;
							}

							// Role found! Display the success message
							const rolesSection = document.querySelector('#roles-section');
							rolesSection.scrollIntoView({ behavior: 'smooth', block: 'start', inline: 'start' });
							// Role found, stop polling
							this.roleResolved = true;
							this.roleFound = true;
							return;
						} catch (error) {
							// eslint-disable-next-line no-console
							console.error('Failed to check role:', error);
							this.roleResolved = true;
							this.roleFound = false;
						}
					}

					// If we've exhausted all retries, show a message to refresh manually
					this.roleResolved = true;
					this.roleFound = false;
				},
				getPurchasesNextLink() {
					return window.location.href + '?purch_start_key=' + this.purchasesNextCursor + '_' + this.userId;
				},
				// handleSubdomainPostRes: function(event) {
				// 	// eslint-disable-next-line no-console
				// 	console.log(event)
				// },
				getPurchaseStatus(purchase) {
					return purchase.status.replace(this.statusSettled, 'PAID').replace(this.statusPending, 'INCOMPLETE')
				}
			}
		}
	</script>
	</div>
}
