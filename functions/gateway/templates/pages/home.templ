package pages

import (
	"context"
	"github.com/google/uuid"
	"github.com/meetnearme/api/functions/gateway/helpers"
	"github.com/meetnearme/api/functions/gateway/templates/components"
	"github.com/meetnearme/api/functions/gateway/types"
	"log"
	"os"
	"strconv"
	"strings"
)

script navigateToSlideHandler(index int) {
		const currentIndex = parseInt(document.getElementById('current-slide-index').value);
		const newIndex = currentIndex + index;
		const totalSlides = document.querySelectorAll('.carousel-item').length;

		// Only proceed if newIndex is within bounds (0 to totalSlides-1)
		if (newIndex >= 0 && newIndex < totalSlides) {
				const slide = document.getElementById(`slide-${newIndex}`);
				if (slide) {
						slide.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'start' });
						document.getElementById('current-slide-index').value = newIndex;
						if (newIndex == 0) {
								document.getElementsByClassName('carousel-control-left')[0].classList.add('hidden');
						} else {
								document.getElementsByClassName('carousel-control-left')[0].classList.remove('hidden');
						}
						if (newIndex == totalSlides - 1) {
								document.getElementsByClassName('carousel-control-right')[0].classList.add('hidden');
						} else {
								document.getElementsByClassName('carousel-control-right')[0].classList.remove('hidden');
						}
				}
		}
}

templ ReShareButton(ev types.Event) {
	// add top right fixed icon for re-share
	<div class="dropdown dropdown-end absolute top-4 right-4 z-40">
		<div tabindex="0" role="button" class="btn   btn-circle"><svg class="w-6 h-6 flex-none shrink-0 grow-0 fill-current" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#1f1f1f"><path d="M480-160q-33 0-56.5-23.5T400-240q0-33 23.5-56.5T480-320q33 0 56.5 23.5T560-240q0 33-23.5 56.5T480-160Zm0-240q-33 0-56.5-23.5T400-480q0-33 23.5-56.5T480-560q33 0 56.5 23.5T560-480q0 33-23.5 56.5T480-400Zm0-240q-33 0-56.5-23.5T400-720q0-33 23.5-56.5T480-800q33 0 56.5 23.5T560-720q0 33-23.5 56.5T480-640Z"></path></svg></div>
		<ul tabindex="0" class="dropdown-content menu bg-base-100 rounded-box z-[1] w-32 p-2 shadow">
			<li>
				<button id={ "re-share-" + ev.Id } @click="reShareEvent(event)">
					<svg class="w-6 h-6 flex-none shrink-0 grow-0 fill-current" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#currentColor"><path d="M482-160q-134 0-228-93t-94-227v-7l-64 64-56-56 160-160 160 160-56 56-64-64v7q0 100 70.5 170T482-240q26 0 51-6t49-18l60 60q-38 22-78 33t-82 11Zm278-161L600-481l56-56 64 64v-7q0-100-70.5-170T478-720q-26 0-51 6t-49 18l-60-60q38-22 78-33t82-11q134 0 228 93t94 227v7l64-64 56 56-160 160Z"></path></svg>
					&nbsp;Re share
				</button>
			</li>
		</ul>
	</div>
}

const eventTitleDataId = "event-title"
const eventLocationDataId = "event-location"
const eventStartTimeDataId = "event-start-time"
const eventUrlDataId = "data-url"

templ EventsInner(events []types.Event, mode string, roleClaims []helpers.RoleClaim, userId string, pageUser *types.UserSearchResult) {
	if mode == helpers.EV_MODE_UPCOMING || mode == "" {
		if (len(events) < 1) {
			<p class="text-md md:text-lg text-center mt-5">
				No events found, try changing your filters like location, date, and time, or
				<br/>
				<br/>
				<a class="btn btn-primary btn-small" href={ templ.SafeURL("/?radius=" + strconv.FormatFloat(helpers.DEFAULT_EXPANDED_SEARCH_RADIUS, 'f', -1, 64)) }>Expand Your Search Radius</a>
			</p>
		} else {
			for _, ev := range events {
				<div class="flex w-full relative pb-24 md:pb-4">
					if helpers.HasRequiredRole(roleClaims, []string{helpers.Roles[helpers.SuperAdmin], helpers.Roles[helpers.SyndicateAdmin]}) {
						@ReShareButton(ev)
					}
					<a data-umami-event={ "event-list-clk" } data-umami-event-event-id={ ev.Id } class="flex w-full" href={ templ.URL("/event/" + ev.Id) }>
						<img
							loading="lazy"
							src={ helpers.GetImgUrlFromHash(ev) }
							alt=""
							class="object-cover object-position-25-25 w-full aspect-[4/3] md:aspect-[16/9] opacity-50 md:opacity-30 md:hover:opacity-75 transition-all"
						/>
					</a>
					<div class="flex flex-col justify-between w-full p-4 md:p-12 bg-gradient-to-t from-base-100/70 from-80% to-transparent absolute bottom-0 left-0">
						<div class="mb-2">
							<h2 data-id={ eventTitleDataId } class="text-2xl md:text-3xl">{ ev.Name }</h2>
							<p data-id={ eventStartTimeDataId } class="text-sm md:text-base">{ helpers.GetDateOrShowNone(ev.StartTime, ev.Timezone) } - { helpers.GetTimeOrShowNone(ev.StartTime, ev.Timezone) } | { ev.Address }</p>
						</div>
						<br/>
						<a data-id={ eventUrlDataId } data-umami-event={ "event-list-clk" } data-umami-event-event-id={ ev.Id } href={ templ.URL("/event/" + ev.Id) } class="btn btn-primary btn-block mb-2 md:mb-3">
							LEARN MORE
							&rarr;
						</a>
					</div>
				</div>
			}
		}
	}
	if mode == helpers.EV_MODE_CAROUSEL {
		if (len(events) < 1) {
			<p class="text-md md:text-lg text-center mt-5">
				This event series has no events yet.
			</p>
		} else {
			<div class="carousel-container relative w-full">
				<div class="carousel rounded-box max-w-full relative mb-4">
					<input type="hidden" id="current-slide-index" value="0"/> <!-- Hidden input to track current slide -->
					for idx, ev := range events {
						<div id={ "slide-" + strconv.Itoa(idx) } class="carousel-item bg-base-200 flex-shrink-0 w-48 snap-start mr-4 last:mr-0 whitespace-nowrap">
							<a href={ templ.URL("/event/" + ev.Id) } class="block p-4 rounded-lg">
								<div class="text-lg font-semibold">{ helpers.GetDateOrShowNone(ev.StartTime, ev.Timezone) }</div>
								<div class="text-md">{ helpers.GetTimeOrShowNone(ev.StartTime, ev.Timezone) }</div>
							</a>
						</div>
					}
				</div>
				<button
					class="btn btn-circle carousel-control-left hidden"
					onClick={ navigateToSlideHandler(-1) }
				>‚ùÆ</button>
				<button
					class="btn btn-circle carousel-control-right"
					onClick={ navigateToSlideHandler(1) }
				>‚ùØ</button>
			</div>
		}
	}
	if mode == helpers.EV_MODE_LIST {
		if (len(events) < 1) {
			<p class="text-md md:text-lg text-center mt-5">
				No events found.
				<br/>
				<br/>
				<a class="btn btn-primary btn-small" href={ templ.SafeURL("/?radius=" + strconv.FormatFloat(helpers.DEFAULT_EXPANDED_SEARCH_RADIUS, 'f', -1, 64)) }>Expand Your Search</a>
			</p>
		} else {
			for _, ev := range events {
				<div class="flex w-full relative pb-12 md:pb-4">
					if userId != pageUser.UserID && helpers.HasRequiredRole(roleClaims, []string{helpers.Roles[helpers.SuperAdmin], helpers.Roles[helpers.SyndicateAdmin]}) {
						@ReShareButton(ev)
					}
					if userId == pageUser.UserID {
						<div class="absolute top-2 right-2 bg-base-100 rounded-full px-2 z-10 leading-none">
							<div class="form-control">
								<label class="cursor-pointer label">
									<span class="label-text mr-2" x-text={ "selectedEvents['" + ev.Id + "'] ? 'Remove' : 'Select'" }></span>
									<input
										id={ ev.Id }
										name={ "event-" + ev.Id }
										value={ ev.Id }
										type="checkbox"
										class="checkbox checkbox-sm checkbox-primary"
										@change={ "selectEvent('" + ev.Id + "')" }
										:checked={ "selectedEvents['" + ev.Id + "'] || false" }
									/>
								</label>
							</div>
						</div>
					}
					<a data-umami-event={ "event-list-clk" } data-umami-event-event-id={ ev.Id } class="flex w-full" href={ templ.URL("/event/" + ev.Id) }>
						<img
							loading="lazy"
							src={ helpers.GetImgUrlFromHash(ev) }
							alt=""
							class="object-cover object-position-25-25 w-full aspect-[4/1] md:aspect-[4/1] opacity-30 md:hover:opacity-75 transition-all"
						/>
					</a>
					<div class="flex justify-between w-full p-2 md:py-8 bg-gradient-to-t from-base-100/70 from-80% to-transparent absolute bottom-0 left-0">
						<div class="mb-2">
							<h2 data-id={ eventTitleDataId } class="text-xl font-bold">{ ev.Name }</h2>
							<p data-id={ eventStartTimeDataId } class="text-sm md:text-base">{ helpers.GetDateOrShowNone(ev.StartTime, ev.Timezone) } - { helpers.GetTimeOrShowNone(ev.StartTime, ev.Timezone) } | { ev.Address }</p>
						</div>
						<a data-id={ eventUrlDataId } data-umami-event={ "event-list-clk" } data-umami-event-event-id={ ev.Id } href={ templ.URL("/event/" + ev.Id) } class="btn btn-primary mb-2 md:mb-3">
							if ev.HasPurchasable {
								BUY TICKETS
								&rarr;
							} else {
								LEARN MORE
								&rarr;
							}
						</a>
					</div>
				</div>
			}
		}
	}
	if mode == helpers.EV_MODE_ADMIN_LIST {
		<h3 class="text-2xl font-bold my-10">Event Admin</h3>
		<table class="table table-fixed top-align bg-base-100 table-pin-rows table-zebra">
			<thead>
				<tr>
					<th></th>
					<th colspan="6">Event</th>
					<th colspan="2">Status</th>
					<th colspan="2">Start</th>
					<th colspan="2">End</th>
				</tr>
			</thead>
			<tbody>
				for idx, ev := range events {
					<tr class="border-t-2 border-base-300">
						<td>
							if idx % 2 == 0 {
								<div class="tooltip" data-tip="Re Shared">
									<svg
										class="w-6 h-6 flex-none shrink-0 grow-0 fill-current"
										xmlns="http://www.w3.org/2000/svg"
										height="24px"
										viewBox="0 -960 960 960"
										width="24px"
										fill="#currentColor"
									><path d="M482-160q-134 0-228-93t-94-227v-7l-64 64-56-56 160-160 160 160-56 56-64-64v7q0 100 70.5 170T482-240q26 0 51-6t49-18l60 60q-38 22-78 33t-82 11Zm278-161L600-481l56-56 64 64v-7q0-100-70.5-170T478-720q-26 0-51 6t-49 18l-60-60q38-22 78-33t82-11q134 0 228 93t94 227v7l64-64 56 56-160 160Z"></path></svg>
								</div>
							}
						</td>
						<td colspan="6">
							<a class="link link-primary" href={ templ.URL("/admin/event/" + ev.Id + "/edit") }>{ ev.Name }</a>
							if ev.EventSourceType == helpers.ES_SERIES_PARENT || ev.EventSourceType == helpers.ES_SERIES_PARENT_UNPUB {
								<br/>
								<strong>Event Series</strong>
							}
							<br/>
							Created: { helpers.FormatTimeMMDDYYYY(ev.CreatedAt) }
							<br/>
							Updated: { helpers.FormatTimeMMDDYYYY(ev.UpdatedAt) }
						</td>
						<td colspan="2">
							if strings.HasPrefix(ev.EventSourceType, helpers.UNPUB_SUFFIX) {
								Unpublished
							} else {
								Published
							}
						</td>
						<td colspan="2">
							{ helpers.FormatTimeMMDDYYYY(ev.StartTime) }
						</td>
						<td colspan="2">
							if ev.EndTime > 0 {
								{ helpers.FormatTimeMMDDYYYY(ev.EndTime) }
							}
						</td>
					</tr>
				}
			</tbody>
		</table>
	}
}

func GetCityCountryFromLocation(cfLocation helpers.CdnLocation, latStr, lonStr, origLat, origLon, origQueryLocation string) string {
	if origQueryLocation != "" {
		return origQueryLocation
	} else if cfLocation.City != "" && cfLocation.CCA2 != "" {
		return cfLocation.City + ", " + cfLocation.CCA2
	} else if latStr != "" && lonStr != "" {
		return latStr + ", " + lonStr
	} else if cfLocation.City == "" && origLat != "" && origLon != "" {
		return origLat + ", " + origLon
	} else {
		return helpers.Cities[0].City + ", " + helpers.Cities[0].State
	}
}

func GetCitiesAsJsonStr() string {
	cityData := make([]map[string]interface{}, 0, 200)
	for _, city := range helpers.Cities[:50] {
		cityData = append(cityData, map[string]interface{}{
			"id":        uuid.New(),
			"name":      city.City,
			"state":     city.State,
			"latitude":  city.Latitude,
			"longitude": city.Longitude,
			"label":     city.City + ", " + city.State + ", US",
		})
	}

	cityStateJsonString, err := templ.JSONString(cityData)
	if err != nil {
		// Handle the error appropriately
		log.Printf("Error creating JSON string: %v", err)
		cityStateJsonString = "[]" // Fallback to empty array
	}

	return cityStateJsonString
}

templ FilterButton() {
	<button type="button" onclick="document.getElementById('flyout-tab-filters').click(); document.getElementById('main-drawer').click();" style="display: inline-block;" class="btn btn-ghost">
		@components.Icon("filter")
	</button>
}

func GetPageUserID(pageUser *types.UserSearchResult) string {
	if pageUser == nil {
		return ""
	}
	return pageUser.UserID
}

func GetDefaultRadius(cfLocation helpers.CdnLocation) string {
	if cfLocation.City == "" {
		return strconv.FormatFloat(helpers.DEFAULT_EXPANDED_SEARCH_RADIUS, 'f', -1, 64)
	}
	return strconv.FormatFloat(helpers.DEFAULT_SEARCH_RADIUS, 'f', -1, 64)
}

templ HomePage(ctx context.Context, events []types.Event, pageUser *types.UserSearchResult, cfLocation helpers.CdnLocation, latStr, lonStr, origLat, origLong, origQueryLocation string) {
	{{
	roleClaims := []helpers.RoleClaim{}
	if claims, ok := ctx.Value("roleClaims").([]helpers.RoleClaim); ok {
		roleClaims = claims
	}
	}}
	{{
	userInfo := helpers.UserInfo{}
	if _, ok := ctx.Value("userInfo").(helpers.UserInfo); ok {
		userInfo = ctx.Value("userInfo").(helpers.UserInfo)
	}
	userId := ""
	if userInfo.Sub != "" {
		userId = userInfo.Sub
	}
	}}
	// we assume this is "home" and not a community / user profile page
	if pageUser == nil {
		<div class="header-hero">
			<h1 class="text-xl md:text-4xl text-center mb-5">
				<span class="opener">_People_ Over Screens!</span>
				<br/>
				<span>Find Connection at Local Events.</span>
				// <span class="opener">Journey to exotic realms <br/> unreachable by AI bots üöÄ</span>
			</h1>
		</div>
	} else {
		<div class="space-y-10" x-data="getCompetitionsState()">
			<h1 class="text-5xl alt-title font-bold text-center uppercase">{ pageUser.DisplayName }</h1>
			if pageUser.Metadata != nil && pageUser.Metadata[helpers.META_ABOUT_KEY] != "" {
				<h2 class="text-3xl font-bold uppercase my-10">About</h2>
				<div class="prose prose-invert max-w-none">
					@templ.Raw(pageUser.Metadata[helpers.META_ABOUT_KEY])
				</div>
			}
			<template x-if="competitions?.length">
				<div>
					<h2 class="text-3xl font-bold uppercase my-10">Competitions</h2>
					<template x-for="competition in competitions">
						<div>
							<h3 x-text="competition.name" class="text-2xl font-bold my-10"></h3>
							<h4 class="text-xl font-bold my-2 uppercase">Schedule</h4>
							<template x-if="rounds && rounds[competition.id]">
								<div>
									<template x-for="(eventRounds, eventId) in rounds[competition.id]">
										<div>
											<template x-if="eventId !== fakeEventId">
												<h3 class="text-xl font-bold my-2">
													<a class="link link-text" :href="`/event/${eventId}`">
														Event #<span x-text="Object.keys(rounds[competition.id]).indexOf(eventId) + 1"></span>
													</a>
												</h3>
											</template>
											<template x-if="eventId === fakeEventId">
												<h3 class="text-xl font-bold my-2">Upcoming</h3>
											</template>
											<template x-for="round in eventRounds">
												<div class="flex justify-between">
													<template x-if="round?.isVotingOpen">
														<div>
															<div class="tooltip tooltip-right w-6 mr-2" data-tip="Voting Open">
																<span aria-label="Voting Open" class="loading loading-ring loading-xs text-primary"></span>
															</div>
															<span class="badge badge-primary mr-2">Voting Open</span>
														</div>
													</template>
													<template x-if="!round?.isVotingOpen">
														<div class="w-6 mr-2"></div>
													</template>
													<div class="grow" x-text="round?.roundName"></div>
												</div>
											</template>
										</div>
									</template>
								</div>
							</template>
							<div class="divider my-10"></div>
							<template x-if="leaderboards && leaderboards[competition.id]">
								<div>
									<h3 class="text-xl font-bold my-2 uppercase">Standings</h3>
									<template x-for="[teamId, score] in Object.entries(leaderboards[competition.id])">
										<div class="flex justify-between border-b border-gray-700">
											<div x-text="users?.find?.(user => user?.userId === teamId)?.displayName"></div>
											<div x-text="'Score: ' + score"></div>
										</div>
									</template>
								</div>
							</template>
						</div>
					</template>
				</div>
			</template>
		</div>
	}
	<div
		class="min-h-screen"
	>
		<div x-data="getHomeState()">
			<div class="card border border-base-300 bg-base-200 p-4 pb-2 md:p-10 md:pb-6 rounded-box mb-4">
				// full width search bar
				<h2 class="text-xl md:text-2xl body-font font-bold mb-4 uppercase text-center">What type of local events you're looking to find?</h2>
				<form class="show-on-focus-parent" @submit.prevent="$store.urlState.setParam('q', document.getElementById('search-input').value)">
					<div class="join w-full">
						<label class="input input-bordered rounded-full flex join-item items-center gap-2 w-full">
							<input
								id="search-input"
								class="w-full grow"
								type="text"
								placeholder="I want to exercise with a group"
								:value="$store.urlState.q || ''"
								autocomplete="off"
							/>
							@FilterButton()
						</label>
						<button
							type="submit"
							id="search-submit-btn"
							class="btn btn-primary join-item"
						>Search</button>
					</div>
					<div class="mb-4 relative show-on-focus-child">
						// search examples
						<div class="flex gap-2 items-center overflow-x-auto pb-3 pt-4">
							<template x-for="(example, index) in $store.filters.getSearchExamples()" :key="index">
								<button
									type="button"
									@click="$store.urlState.setParam('q', example)"
									class="btn btn-sm btn-outline font-thin flex-shrink-0 whitespace-nowrap"
									x-text="example"
								></button>
							</template>
						</div>
						<!-- Fade indicator for more content -->
						<div class="absolute right-0 top-0 bottom-0 w-8 bg-gradient-to-l from-base-200 to-transparent pointer-events-none"></div>
					</div>
				</form>
				// input form for importing events from link
				<div class="text-sm md:text-base mt-2 mb-2 text-center">
					Showing events within <span class="font-bold" x-text="$store.urlState.radius || defaultRadius"></span> miles of
					<button class="link link-text font-bold" @click="document.getElementById('flyout-tab-filters').click(); document.getElementById('main-drawer').click();">
						<span x-text="$store.urlState.location || document.querySelector('#alpine-state').getAttribute('data-city-label-initial')"></span>
					</button>
					<template x-if="$store.urlState.q">
						<span>&nbsp;searching for "<strong x-text="$store.urlState.q"></strong>"</span>
					</template>
					<template x-if="$store.urlState.start_time">
						<span>&nbsp;starting <strong x-text="$store.urlState.queryParamToReadableTime($store.urlState.start_time)"></strong></span>
					</template>
					<template x-if="$store.urlState.address">
						<span>&nbsp;at location <strong x-text="$store.urlState.address"></strong></span>
					</template>
					&nbsp;
					<button @click="document.getElementById('flyout-tab-filters').click(); document.getElementById('main-drawer').click();" class="btn btn-xs bg-base-300">Modify</button>
				</div>
				// event link import form
				<div class="w-full md:w-5/6 mx-auto mt-4">
					<form onsubmit="const v=document.getElementById('event-link-input').value; if(!v) return; window.location.replace(`${window.location.origin}/admin/add-event-source/?import_from=${encodeURIComponent(v)}`); return false;">
						<p class="text-sm md:text-base mb-2 text-center">Know of a cool event or community? Drop a link below. We'll scan the page for events!</p>
						<div class="join w-full rainbow-box z-[1]">
							<label class="input input-bordered rounded-full flex join-item items-center gap-2 w-full">
								<input
									id="event-link-input"
									class="w-full grow"
									type="text"
									placeholder="Add events via link"
									autocomplete="off"
									type="url"
									inputmode="url"
								/>
							</label>
							<button
								class="btn btn-outline join-item"
								type="submit"
							>Add</button>
						</div>
					</form>
				</div>
			</div>
			<div class="pb-4">
				<form
					id="event-search-form"
					class="flex"
					novalidate
					if pageUser == nil {
						hx-get="/api/html/events"
					} else {
						hx-get={ `/api/html/events?list_mode=` + helpers.EV_MODE_LIST }
					}
					hx-indicator="#events-container"
					hx-ext="json-enc"
					hx-target="#events-container-inner"
					hx-disabled-elt="button[type='submit']"
					@submit.prevent=""
					hx-vals="js:{...sendParmsFromQs()}"
				>
					<input
						:value="$store.urlState.start_time || ''"
						id="start_time"
						type="hidden"
						name="start_time"
					/>
					<input
						:value="$store.urlState.end_time || ''"
						id="end_time"
						type="hidden"
						name="end_time"
					/>
					<input
						:value="$store.urlState.q || ''"
						id="q"
						type="hidden"
						name="q"
					/>
					<input
						:value="$store.urlState.radius || ''"
						id="radius"
						type="hidden"
						name="radius"
					/>
					<input
						:value="$store.urlState.lat || ''"
						id="lat"
						type="hidden"
						name="lat"
					/>
					<input
						:value="$store.urlState.lon || ''"
						id="lon"
						type="hidden"
						name="lon"
					/>
					<div class="flex flex-auto space-x-2">
						<button
							type="button"
							:class="{ 'btn-primary': $store.urlState.start_time === 'this_month' }"
							class="btn grow px-2 py-2 text-md md:text-xl"
							@click="$store.urlState.setParam('start_time', 'this_month')"
						>
							THIS MONTH
						</button>
						<button
							type="button"
							:class="{ 'btn-primary': $store.urlState.start_time === 'today' }"
							class="btn grow px-2 py-2 text-md md:text-xl"
							@click="$store.urlState.setParam('start_time', 'today')"
						>
							TODAY
						</button>
						<button
							type="button"
							:class="{ 'btn-primary': $store.urlState.start_time === 'tomorrow' }"
							class="btn grow px-2 py-2 text-md md:text-xl"
							@click="$store.urlState.setParam('start_time', 'tomorrow')"
						>
							TOMORROW
						</button>
						<button
							type="button"
							:class="{ 'btn-primary': $store.urlState.start_time === 'this_week' }"
							class="btn grow px-2 py-2 text-md md:text-xl"
							@click="$store.urlState.setParam('start_time', 'this_week')"
						>
							THIS WEEK
						</button>
					</div>
				</form>
			</div>
			<main id="events-container">
				if pageUser == nil {
					<div class="htmx-indicator flex flex-wrap items-center justify-center my-4">
						<span class="loading loading-spinner loading-lg text-primary"></span>
					</div>
					<div id="events-container-inner">
						@EventsInner(events, "", roleClaims, userId, pageUser)
					</div>
				} else {
					<div class="relative">
						// share / export buttons for users viewing their own events
						if pageUser.UserID == userId {
							// shim for preventing floating buttons from covering the content
							<div class="flex md:hidden leading-5">
								<br/>
							</div>
							<div class="absolute top-0 right-0">
								<template x-if="Object.keys(selectedEvents).length > 0">
									<div class="indicator">
										<span x-text="Object.keys(selectedEvents).length" class="indicator-item badge badge-primary"></span>
										<div class="dropdown dropdown-end">
											<div tabindex="0" role="button" class="btn">Export</div>
											<ul tabindex="0" class="dropdown-content menu bg-base-100 rounded-box z-[1] w-48 p-2 shadow">
												<li><a @click="exportSelectedEvents('rich')">Rich Text</a></li>
												<li><a @click="exportSelectedEvents('html')">HTML</a></li>
											</ul>
										</div>
									</div>
								</template>
								<button class="btn btn-ghost" @click="clearAllSelections()">
									Clear
								</button>
								<button class="btn btn-primary" @click="selectAllEvents()">
									Select All Events
								</button>
							</div>
						}
						<div role="tablist" class="tabs tabs-bordered">
							<input
								type="radio"
								name="org-events-tabs"
								role="tab"
								class="tab text-lg leading-5 uppercase hidden md:flex"
								aria-label="Upcoming"
								checked="checked"
							/>
							<div role="tabpanel" class="tab-content py-10">
								<div class="htmx-indicator flex flex-wrap items-center justify-center my-4">
									<span class="loading loading-spinner loading-lg text-primary"></span>
								</div>
								<div id="events-container-inner">
									@EventsInner(events, helpers.EV_MODE_LIST, roleClaims, userId, pageUser)
								</div>
							</div>
							<input
								type="radio"
								name="org-events-tabs"
								role="tab"
								class="tab text-lg leading-5 uppercase hidden md:flex"
								aria-label="Past"
							/>
							<div role="tabpanel" class="tab-content p-10">(Coming Soon...)</div>
						</div>
					</div>
				}
			</main>
			<template x-if="showToast === true">
				<div class="toast m-4 z-50">
					<div :class="() => { switch (toastContent.type) { case 'error': return 'alert-error'; case 'info': return 'alert-info'; case 'success': return 'alert-success'; default: return 'alert'; } }" class="alert border border-base-300">
						<span x-text="toastContent.message"></span>
						<div class="block justify-end">
							<button class="btn btn-circle btn-ghost text-2xl float-end" @click="showToast = false">
								<svg class="svg-icon" style="width: 1em; height: 1em; vertical-align: middle; fill: currentColor; overflow: hidden;" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M777.856 280.192l-33.92-33.952-231.872 231.872-231.84-231.872-33.984 33.888 231.872 231.904-231.84 231.84 33.888 33.984 231.904-231.904 231.84 231.872 33.952-33.888-231.872-231.904z"></path></svg>
							</button>
						</div>
					</div>
				</div>
			</template>
		</div>
	</div>
	<script id="alpine-state" data-cities-default-list={ GetCitiesAsJsonStr() } data-city-label-initial={ GetCityCountryFromLocation(cfLocation, latStr, lonStr, origLat, origLong, origQueryLocation) } data-city-latitude-initial={ latStr } data-city-longitude-initial={ lonStr } data-page-user-id={ GetPageUserID(pageUser) } data-fake-event-id={ helpers.COMP_UNASSIGNED_ROUND_EVENT_ID } data-apex-url={ os.Getenv("APEX_URL") } data-default-radius={ GetDefaultRadius(cfLocation) } data-event-title-id={ eventTitleDataId } data-event-start-time-id={ eventStartTimeDataId } data-event-url-id={ eventUrlDataId }>
		document.addEventListener('alpine:init', () => {
			// Reactive URL store - single source of truth with reactivity
			Alpine.store('urlState', {
				// Initialize from URL
				...Object.fromEntries(new URLSearchParams(window.location.search)),

				// Helper to update both store and URL
				setParam(param, value) {
					const url = new URL(window.location.href);
					const params = new URLSearchParams(url.search);

					if (param === 'categories') {
						const categoryString = Array.isArray(value) ? value.join(' | ') : value;
						if (categoryString && categoryString !== '') {
							params.set('categories', categoryString);
							this.categories = categoryString;
						} else {
							params.delete('categories');
							this.categories = '';
						}
					} else {
						if (value && value !== '') {
							params.set(param, value);
							this[param] = value;
						} else {
							params.delete(param);
							this[param] = '';
						}
					}

					// Update URL
					window.history.pushState({}, '', `${url.pathname}?${params.toString()}`);

					// Trigger form submission
					const form = document.getElementById('event-search-form');
					if (form) {
						setTimeout(() => {
							form.requestSubmit();
						}, 50);
					}
				},

				// Helper to sync from URL (for popstate events)
				syncFromURL() {
					const urlParams = new URLSearchParams(window.location.search);

					// Update all known parameters
					['start_time', 'end_time', 'q', 'radius', 'lat', 'lon', 'categories', 'location'].forEach(param => {
						const value = urlParams.get(param) || '';
						this[param] = value;
					});
				},

				queryParamToReadableTime(param) {
					if (param === 'this_month') return 'this month';
					if (param === 'today') return 'today';
					if (param === 'tomorrow') return 'tomorrow';
					if (param === 'this_week') return 'this week';
					if (param === 'this_year') return 'this year';
					if (param === '') return 'within 90 days';
					return '';
				}
			});

			// Filters store - ONLY for sidebar draft state
			Alpine.store('filters', {
				// Draft state properties
				radius: '',
				categories: [],

				// Initialize draft state from current URL
				initFromUrl() {
					this.radius = Alpine.store('urlState').radius || document.querySelector('#alpine-state').getAttribute('data-default-radius');
					const categoriesString = Alpine.store('urlState').categories || '';
					this.categories = categoriesString ? categoriesString.split(' | ') : [];
				},

				// Utility functions
				getSearchExamples() {
					const searchPlaceholderExamples = [
						'I want to meet people who enjoy theater',
						'I want to meet active people',
						'I want to exercise with a group',
						'I want to find a running group',
						'I want to find a hiking group',
						'I want to find a biking group',
						'I want to find a yoga group',
						'I want to find a dance group',
						'I want to find a cooking group',
						'I want to find a book club',
						'I want to find a wine tasting group',
						'I want to meet people interested in nature',
						'I want to meet people interested in natural living',
						'I want to meet people interested in healthy eating',
						'I want to meet people interested in sustainable living',
						'I want to meet people interested in alternative medicine',
						'I want to meet people interested in spirituality',
						'I want to meet people interested in personal development',
						'I want to meet people interested in personal growth',
					];
					const shuffleArray = array => {
						for (let i = array.length - 1; i > 0; i--) {
							const j = Math.floor(Math.random() * (i + 1));
							[array[i], array[j]] = [array[j], array[i]];
						}
						return array;
					};
					return shuffleArray([...searchPlaceholderExamples]);
				}
			});

			// Keep location store
			Alpine.store('location', {
				selected: {
					label: document.querySelector('#alpine-state').getAttribute('data-city-label-initial'),
					latitude: document.querySelector('#alpine-state').getAttribute('data-city-latitude-initial'),
					longitude: document.querySelector('#alpine-state').getAttribute('data-city-longitude-initial'),
				},
				setSelectedLocation(location) {
					this.selected = location
				},
			});
		});

		// NOTE: this is used by htmx to get the data-attributes
		// eslint-disable-next-line no-unused-vars
		function sendParmsFromQs() {
			const urlParams = new URLSearchParams(window.location.search);
			return {
				...(document.querySelector('#alpine-state').getAttribute('data-page-user-id') !== "") ? { owners: document.querySelector('#alpine-state').getAttribute('data-page-user-id') } : {},
				...(urlParams.get('start_time')?.length > 1) ? { start_time: urlParams.get('start_time') } : {},
				...(urlParams.get('end_time')?.length > 1) ? { end_time: urlParams.get('end_time') } : {},
				...(urlParams.get('q')?.length > 1) ? { q: urlParams.get('q') } : {},
				...(urlParams.get('radius')?.length > 1) ? { radius: urlParams.get('radius') } : {},
				...(urlParams.get('lat')?.length > 1) ? { lat: urlParams.get('lat') } : {},
				...(urlParams.get('lon')?.length > 1) ? { lon: urlParams.get('lon') } : {},
				...(urlParams.get('categories')?.length > 1) ? { categories: urlParams.get('categories') } : {},

			}
		}

		function getLocationSearchState() {
			return {
				allOptions: JSON.parse(
					document.querySelector('#alpine-state').getAttribute('data-cities-default-list')
				).map((city) => ({
					label: city.label,
					value: city.id,
					latitude: city.latitude,
					longitude: city.longitude,
				})),
				options: [],
				isOpen: false,
				openedWithKeyboard: false,
				isLoading: false,
				selectedOption: {
					label: Alpine.store('location').selected.label,
					latitude: Alpine.store('location').selected.latitude,
					longitude: Alpine.store('location').selected.longitude,
				},
				async fetchLocations(query) {
					if (query.length >= 3) {
						this.isLoading = true;
						this.options = await fetch(`/api/locations?q=${query}`).then(res => {
							return res.json()
						}).then(json => {
							return json.map((city) => ({
								label: city.label,
								value: city.id,
								latitude: city.latitude,
								longitude: city.longitude,
							}))
						})
						.catch(error => {
							// eslint-disable-next-line no-console
							console.error('Error fetching locations:', error);
							return [];
						})
						.finally(() => {
							this.isLoading = false;
						});
					}
				},
				setSelectedOption(option) {
					this.selectedOption = option
					this.isOpen = false
					this.openedWithKeyboard = false
					this.$refs.hiddenTextField.value = option.value
					// Update lat and lon in the parent component
					this.$dispatch('location-dropdown', { option: { ...option } })
				},

				locationAccessDeclined: false,
				cityNotFound: false,
				findAndSetLocation() {

				const success = (position) => {
					this.locationAccessDeclined = false;
					this.cityNotFound = false;
					const latitude = position.coords.latitude.toFixed(3);
					const longitude = position.coords.longitude.toFixed(3);
          const query = `lat=${latitude}&lon=${longitude}`
					fetch(`/api/location/city?${query}`)
					.then(async (response) => {
						if (!response.ok) {
							throw new Error(`City lookup failed with query ${query} status: (${response.status})`);
						}
							return response.json();
					})
					.then(data => {
						if (data.city != "") {
							this.selectedOption = {
								label: data.city,
								latitude: latitude,
								longitude: longitude,
							}
							// changing the locationDropdown triggers the url params to update
							this.locationDropdown = this.selectedOption
							Alpine.store('location').setSelectedLocation(this.selectedOption)
							this.$dispatch('location-dropdown', { option: { ...this.selectedOption } });
						} else {
							this.cityNotFound = true
						}
					})
					.catch(error => {
						// eslint-disable-next-line no-console
						console.error("Error fetching city:", error);
					})
				}

				// This gets executed if the user does not allow the browser to access their location
				const error = () => {
					this.locationAccessDeclined = true
				}

				navigator.geolocation.getCurrentPosition(success, error);
				this.isOpen = false
				this.openedWithKeyboard = false
				},

				getFilteredOptions(query) {
					this.options = this.allOptions.filter((option) =>
						option.label.toLowerCase().includes(query.toLowerCase()),
					)
					if (this.options.length === 0) {
						this.$refs.noResultsMessage.classList.remove('hidden')
					} else {
						this.$refs.noResultsMessage.classList.add('hidden')
					}
				},
				handleKeydownOnOptions(event) {
					// if the user presses backspace or the alpha-numeric keys, focus on the search field
					if (/^[a-zA-Z0-9]$/.test(event.key) || event.key === 'Backspace') {
						this.$refs.loc_search.focus()
					}
				},
			}
		}

		function getHomeState() {
			return {
				async init() {
					// Handle browser back/forward navigation
					window.addEventListener('popstate', () => {
						// Sync Alpine store from URL
						Alpine.store('urlState').syncFromURL();

						// Trigger form submission
						const form = document.getElementById('event-search-form');
						if (form) {
							form.requestSubmit();
						}
					});
				},
				pageUserId: document.querySelector('#alpine-state').getAttribute('data-page-user-id'),
				defaultRadius: document.querySelector('#alpine-state').getAttribute('data-default-radius'),
				showToast: false,
				toastContent: {
					type: '',
					message: '',
				},
				selectedEvents: {}, // Changed from array to object/map
				selectEvent(eventId) {
					// Toggle the selection state for this event
					if (this.selectedEvents[eventId]) {
						delete this.selectedEvents[eventId];
					} else {
						this.selectedEvents[eventId] = true;
					}
				},
				selectAllEvents() {
					// Select all event checkboxes that are currently visible
					const eventCheckboxes = document.querySelectorAll('input[type="checkbox"][name^="event-"]');
					eventCheckboxes.forEach(checkbox => {
						const eventId = checkbox.value;
						this.selectedEvents[eventId] = true;
					});
				},
				clearAllSelections() {
					this.selectedEvents = {};
				},
				getSelectedEventIds() {
					return Object.keys(this.selectedEvents).filter(id => this.selectedEvents[id]);
				},
				async reShareEvent(event) {
					const eventId = event.currentTarget.id.split('re-share-')[1]
					// send a post request to the re-share endpoint
					if (!eventId) {
						this.showToast = true;
						this.toastContent = {
							type: 'error',
							message: 'Cannot locate event ID for re-sharing.',
						};
						return
					}

					try {
						const res = await fetch(`/api/data/re-share?event_id=${eventId}`, {
							method: 'POST',
							headers: {
								'Content-Type': 'application/json',
							},
						})

						if (res.ok) {
							this.showToast = true;
							this.toastContent = {
								type: 'success',
								message: 'Event re-shared successfully!',
							};
						} else {
							this.showToast = true;
							this.toastContent = {
								type: 'error',
								message: `Failed to re-share event. Status: ${res.status}`,
							};
						}
					} catch (error) {
						this.showToast = true;
						this.toastContent = {
							type: 'error',
							message: 'An error occurred while re-sharing the event.',
						};
						// eslint-disable-next-line no-console
						console.error('Re-share error:', error);
					}
				},
				async exportSelectedEvents(format) {
					const selectedEventIds = this.getSelectedEventIds();
					if (selectedEventIds.length === 0) {
						this.showToast = true;
						this.toastContent = {
							type: 'error',
							message: 'No events selected for export.',
						};
						return;
					}

					try {
						const eventData = [];

						// Get data-id attribute values from the alpine-state element
						const alpineState = document.querySelector('#alpine-state');
						const eventTitleId = alpineState.getAttribute('data-event-title-id');
						const eventStartTimeId = alpineState.getAttribute('data-event-start-time-id');
						const eventUrlId = alpineState.getAttribute('data-event-url-id');

						// Collect data from selected events using data-id attributes
						selectedEventIds.forEach(eventId => {
							const eventContainer = document.querySelector(`input[value="${eventId}"]`)?.closest('.flex.w-full.relative');
							if (eventContainer) {
								const titleElement = eventContainer.querySelector(`[data-id="${eventTitleId}"]`);
								const timeElement = eventContainer.querySelector(`[data-id="${eventStartTimeId}"]`);
								const urlElement = eventContainer.querySelector(`[data-id="${eventUrlId}"]`);

								if (titleElement && timeElement && urlElement) {
									eventData.push({
										title: titleElement.textContent.trim(),
										time: timeElement.textContent.trim(),
										url: urlElement.href
									});
								}
							}
						});

						if (eventData.length === 0) {
							this.showToast = true;
							this.toastContent = {
								type: 'error',
								message: 'Could not collect event data for export.',
							};
							return;
						}

												// Create temporary off-screen element for copying
						const tempElement = document.createElement('div');
						tempElement.style.position = 'absolute';
						tempElement.style.left = '-9999px';
						tempElement.style.top = '-9999px';
						tempElement.style.opacity = '0';
						tempElement.style.pointerEvents = 'none';
						document.body.appendChild(tempElement);

						// Create content based on format
						if (format === 'rich') {
							// Rich text format with actual bold styling
							eventData.forEach((event, index) => {
								if (index > 0) {
									tempElement.appendChild(document.createElement('br'));
									tempElement.appendChild(document.createElement('br'));
								}

								// Create bold title
								const titleElement = document.createElement('strong');
								titleElement.textContent = event.title;
								tempElement.appendChild(titleElement);

								// Add line break
								tempElement.appendChild(document.createElement('br'));

								// Add time/location
								const timeElement = document.createTextNode(event.time);
								tempElement.appendChild(timeElement);

								// Add line break
								tempElement.appendChild(document.createElement('br'));

								// Add URL
								const urlElement = document.createTextNode(event.url);
								tempElement.appendChild(urlElement);
							});

							// Select the content to preserve formatting
							const range = document.createRange();
							range.selectNode(tempElement);
							const selection = window.getSelection();
							selection.removeAllRanges();
							selection.addRange(range);

							// Copy with formatting
							await navigator.clipboard.write([
								new ClipboardItem({
									'text/html': new Blob([tempElement.innerHTML], { type: 'text/html' }),
									'text/plain': new Blob([tempElement.textContent], { type: 'text/plain' })
								})
							]);

							// Clear selection
							selection.removeAllRanges();

																								} else if (format === 'html') {
							// HTML format - copy actual HTML markup as plain text
							const htmlContent = `<ul>\n${eventData.map(event =>
								`  <li><strong><a href="${event.url}">${event.title}</a></strong><br/>${event.time}</li>`
							).join('\n')}\n</ul>`;

							// Copy HTML markup as plain text so the tags are visible
							await navigator.clipboard.writeText(htmlContent);
						}

						// Clean up
						document.body.removeChild(tempElement);

						// Show success message
						this.showToast = true;
						this.toastContent = {
							type: 'success',
							message: `${eventData.length} event(s) exported to clipboard as ${format === 'rich' ? 'Rich Text' : 'HTML'}.`,
						};

					} catch (error) {
						this.showToast = true;
						this.toastContent = {
							type: 'error',
							message: 'Failed to copy events to clipboard. Please try again.',
						};
						// eslint-disable-next-line no-console
						console.error('Export error:', error);
					}
				}
			}
		}

		// NOTE: this maintains an intentionally independent state for sidebar draft state
		// that is committed to URL params via Alpine.store('urlState') when "Apply Filters" is clicked
		function getFilterFormState() {
				return {
					init() {
						// Initialize draft state from URL state
						Alpine.store('filters').initFromUrl();
						this.radius = Alpine.store('filters').radius;

						const form = document.getElementById('category-search-form')
						form.querySelectorAll('input[type="checkbox"]').forEach(itm => {
							if (Alpine.store('filters').categories.includes(itm.value)) {
								itm.checked = true
							}
						})

						const searchPlaceholderExamples = Alpine.store('filters').getSearchExamples()

						const searchInput = document.querySelector('#search-input')
						if (searchInput) {
							// Fisher-Yates shuffle algorithm
							const shuffleArray = array => {
								for (let i = array.length - 1; i > 0; i--) {
									const j = Math.floor(Math.random() * (i + 1));
									[array[i], array[j]] = [array[j], array[i]];
								}
								return array;
							}

							// Shuffle the array once
							const shuffledExamples = shuffleArray([...searchPlaceholderExamples])
							let currentIndex = 0

							const updatePlaceholder = () => {
								searchInput.placeholder = shuffledExamples[currentIndex]
								currentIndex = (currentIndex + 1) % shuffledExamples.length
							}

							// Set initial placeholder
							updatePlaceholder()

							// Update every 5 seconds
							setInterval(updatePlaceholder, 2500)
						}
					},
					radius: null,
					locationDropdown: null,
					sendCategoriesToQueryParams() {
						const form = document.getElementById('category-search-form')
						// Collect form values
						const formData = new FormData(form);
						const formValues = Object.fromEntries(formData.entries());
						let formVals = []
						Object.keys(formValues).forEach(itm => {
							if (itm.startsWith('itm-')) {
								formVals.push(formValues?.[itm])
							}
						})
						const categoriesString = formVals.join(' | ')

						// Commit categories to URL (triggers syncFromURL automatically)
						Alpine.store('urlState').setParam('categories', categoriesString)
					},
					handleFilterSubmit() {
						// Commit all draft changes to URL state
						this.sendCategoriesToQueryParams();

						if (this.radius) {
							Alpine.store('urlState').setParam('radius', this.radius)
						}

						if (this.locationDropdown) {
							// Commit location changes to URL
							Alpine.store('urlState').setParam('lat', this.locationDropdown.latitude)
							Alpine.store('urlState').setParam('lon', this.locationDropdown.longitude)
							Alpine.store('urlState').setParam('location', this.locationDropdown.label)
							Alpine.store('location').setSelectedLocation(this.locationDropdown)
						}

						// close the drawer
						document.getElementById('main-drawer').click();
					},
				}
			}

		function getCompetitionsState() {
			return {
				async init() {
					await fetch(`/api/competition-config/owner/${this.pageUserId}`).then(res => {
						return res.json()
					}).then(json => {
						const _competitions = json.filter(competition => {
							return competition.endTime > new Date().getTime() / 1000
						})
						this.competitions = _competitions
					});

					// Create an array of promises for fetching competition rounds and leaderboards
					const fetchPromises = this.competitions.flatMap(competition => [
						// Fetch rounds
						fetch(`/api/competition-round/competition/${competition.id}`)
							.then(response => response.json())
							.catch(error => {
								// eslint-disable-next-line no-console
								console.error(`Error fetching rounds for competition ${competition.id}:`, error);
								return null;
							}),
						// Fetch leaderboard
						fetch(`/api/competition-round/competition-sum/${competition.id}`)
							.then(response => response.json())
							.catch(error => {
								// eslint-disable-next-line no-console
								console.error(`Error fetching leaderboard for competition ${competition.id}:`, error);
								return null;
							})
					]);

					// Wait for all requests to complete
					try {
						const results = await Promise.all(fetchPromises);
						// Process results in pairs (rounds and leaderboard for each competition)
						this.rounds = {};
						this.leaderboards = {};
						for (let i = 0; i < results.length; i += 2) {
							const roundsArray = results[i];
							const leaderboardData = results[i + 1];
							if (roundsArray && roundsArray.length > 0) {
								// Group rounds by eventId
								const roundsByEvent = roundsArray.reduce((acc, round) => {
									if (!acc[round.eventId]) {
										acc[round.eventId] = [];
									}
									acc[round.eventId].push(round);
									return acc;
								}, {});
								this.rounds[roundsArray[0].competitionId] = roundsByEvent;
							}
							if (leaderboardData) {
								// Sort the entries by score in descending order
								const sortedEntries = Object.entries(leaderboardData)
									.sort(([, scoreA], [, scoreB]) => scoreB - scoreA);

								// Convert back to object while maintaining sorted order
								this.leaderboards[this.competitions[i / 2].id] = Object.fromEntries(sortedEntries);
							}
						}
					} catch (error) {
						// eslint-disable-next-line no-console
						console.error('Error fetching competition data:', error);
					}

					try {
						const userIds = Object.values(this.leaderboards)
							.flatMap(leaderboard => Object.keys(leaderboard))
							.join(',');
						if (userIds.length > 0) {
							const users = await fetch(`/api/users?ids=${userIds}`).then(res => {
								return res.json()
							})
							this.users = users
						}
					} catch (error) {
						// eslint-disable-next-line no-console
						console.error('Error fetching users:', error);
					}
				},
				competitions: [],
				rounds: {},
				leaderboards: {},
				users: [],
				pageUserId: document.querySelector('#alpine-state').getAttribute('data-page-user-id'),
				fakeEventId: document.querySelector('#alpine-state').getAttribute('data-fake-event-id'),
				apexUrl: document.querySelector('#alpine-state').getAttribute('data-apex-url'),
			}
		}
	</script>
}
