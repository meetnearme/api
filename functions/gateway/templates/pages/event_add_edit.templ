package pages

import (
	"github.com/meetnearme/api/functions/gateway/helpers"
	"github.com/meetnearme/api/functions/gateway/templates/components"
	"github.com/meetnearme/api/functions/gateway/templates/partials"
	"github.com/meetnearme/api/functions/gateway/types"
	"strconv"
	"strings"
)

templ AddOrEditEventPage(pageObj helpers.SitePage, event types.Event, isEditor bool, cfLocationLat float64, cfLocationLon float64, isCompetitionAdmin bool) {
	if event.EventSourceType == helpers.ES_EVENT_SERIES || event.EventSourceType == helpers.ES_EVENT_SERIES_UNPUB {
		<header class="page-header bg-base-100 shadow-md sticky sticky-under-top-nav z-40 py-4">
			<h1 class="text-3xl mb-4 truncate whitespace-nowrap overflow-hidden max-w-full">
				This is a series event, you must edit it's parent
			</h1>
		</header>
	} else {
		<div
			x-data="getAddEditEventState()"
			@child-updated.window="formData.eventChildren[$event.detail.index] = $event.detail.value"
			@lat-updated.window="formData.event.lat = $event.detail.value"
			@lon-updated.window="formData.event.long = $event.detail.value"
			@address-updated.window="formData.event.address = $event.detail.value"
		>
			// NOTE: intentionally hidden fields that users can't affect directly
			<header class="page-header bg-base-100 shadow-md sticky sticky-under-top-nav z-40 py-4">
				<h1 class="text-3xl mb-4 truncate whitespace-nowrap overflow-hidden max-w-full">
					{ pageObj.Name }
					<template x-if="formData.event.id">
						<span>:&nbsp;<a x-text="formData.event.name" target="_blank" class="link link-primary" :href="eventDetailUrl.replace('{}',formData.event.id)"></a></span>
					</template>
					<template x-if="!formData.event.id && formData.event.name">
						{ event.EventSourceType }
						<span x-text=" ': ' + formData.event.name"></span>
					</template>
				</h1>
				<a class="btn btn-sm" href={ templ.URL(strings.Replace(strings.Replace(helpers.SitePages["attendees-event"].Slug, "{"+helpers.EVENT_ID_KEY+"}", event.Id, 1), "{trailingslash:\\/?}", "", 1)) }>View Attendees</a>
			</header>
			<h2 class="text-2xl sticky sticky-under-top-nav subheader bg-base-100 z-40 py-2">Event Overview</h2>
			<div id="basic" class="card border-2 border-base-300 bg-base-200 p-4 md:p-10 rounded-box mb-4">
				<div class="card">
					<label class="form-control w-full max-w-xs">
						<div class="label">Event Name</div>
						<input
							class="input input-bordered w-full"
							id="name"
							type="text"
							placeholder="Enter event name"
							x-model.fill={ "formData.event.name" }
							value={ event.Name }
							:disabled="saveReqInFlight"
						/>
					</label>
					<label class="form-control w-full max-w-xs">
						<div class="label">Publish Status</div>
						<select
							id="publishStatus"
							data-test-id={ event.EventSourceType }
							class="select select-bordered w-full"
							x-model.fill="publishStatus"
							if strings.Contains(event.EventSourceType, helpers.UNPUB_SUFFIX) {
								value={ helpers.UNPUB_SUFFIX }
							} else {
								value={ helpers.PUBLISHED_SUFFIX }
							}
						>
							<option
								value={ helpers.UNPUB_SUFFIX }
								if strings.Contains(event.EventSourceType, helpers.UNPUB_SUFFIX) {
									selected
								}
							>Unpublished</option>
							<option
								value={ helpers.PUBLISHED_SUFFIX }
								if !strings.Contains(event.EventSourceType, helpers.UNPUB_SUFFIX) {
									selected
								}
							>Published</option>
						</select>
					</label>
					<div class="form-control">
						<label class="label" for="description">Description</label>
						<textarea
							class="textarea textarea-bordered w-full"
							id="description"
							placeholder="Enter event description"
							x-model.fill={ "formData.event.description" }
							:disabled="saveReqInFlight"
						>{ event.Description }</textarea>
					</div>
					<div class="form-control">
						<label class="label">Categories</label>
						<div class="categories" id="categoriesList">
							<template x-for="category in formData.event.categories">
								<span
									class="tag badge badge-neutral gap-2 mr-2 mb-4 text-lg py-4 pl-4 pr-2"
								>
									<span x-text="category"></span>
									<button aria-label="remove category" class="btn btn-circle btn-neutral  btn-xs" @click="removeCategory(category)" :disabled="saveReqInFlight">
										<svg
											xmlns="http://www.w3.org/2000/svg"
											class="h-6 w-6"
											fill="none"
											viewBox="0 0 24 24"
											stroke="currentColor"
										>
											<path
												stroke-linecap="round"
												stroke-linejoin="round"
												stroke-width="2"
												d="M6 18L18 6M6 6l12 12"
											></path>
										</svg>
									</button>
								</span>
							</template>
						</div>
						<input
							placeholder="Add categories (press Enter)"
							class="input input-bordered"
							id="categoryInput"
							type="text"
							x-model="categoryInput"
							@keydown="handleCategoryKeydown"
							:disabled="saveReqInFlight"
						/>
					</div>
					<div class="form-control">
						<label class="label">Tags</label>
						<div class="tags" id="tagsList">
							<template x-for="tag in formData.event.tags">
								<span
									class="tag badge badge-neutral gap-2 mr-2 mb-4 text-lg py-4 pl-4 pr-2"
								>
									<span x-text="tag"></span>
									<button aria-label="remove tag" class="btn btn-circle btn-neutral  btn-xs" @click="removeTag(tag)" :disabled="saveReqInFlight">
										<svg
											xmlns="http://www.w3.org/2000/svg"
											class="h-6 w-6"
											fill="none"
											viewBox="0 0 24 24"
											stroke="currentColor"
										>
											<path
												stroke-linecap="round"
												stroke-linejoin="round"
												stroke-width="2"
												d="M6 18L18 6M6 6l12 12"
											></path>
										</svg>
									</button>
								</span>
							</template>
						</div>
						<input
							placeholder="Add tags (press Enter)"
							class="input input-bordered"
							id="tagInput"
							type="text"
							x-model="tagInput"
							@keydown="handleTagKeydown"
							:disabled="saveReqInFlight"
						/>
					</div>
				</div>
				<div class="card">
					<h2 class="text-2xl mt-4">Event Ownership</h2>
					<div class="form-control">
						<div class="form-control">
							<label class="label">{ helpers.GetFieldDisplayName("EventOwners") }</label>
							<div class="tags" id="ownersList">
								<template x-for="owner in owners">
									<span
										class="tag badge badge-neutral gap-2 mr-2 mb-4 text-lg py-4 pl-4 pr-2"
									>
										<template x-if="owner.label">
											<span x-text="owner.label"></span>
										</template>
										<template x-if="!owner.label">
											<span class="loading loading-spinner loading-sm"></span>
										</template>
										<button aria-label="remove owner" class="btn btn-circle btn-neutral  btn-xs" x-on:click="removeOwner(owner)" :disabled="saveReqInFlight">
											<svg
												xmlns="http://www.w3.org/2000/svg"
												class="h-6 w-6"
												fill="none"
												viewBox="0 0 24 24"
												stroke="currentColor"
											>
												<path
													stroke-linecap="round"
													stroke-linejoin="round"
													stroke-width="2"
													d="M6 18L18 6M6 6l12 12"
												></path>
											</svg>
										</button>
									</span>
								</template>
							</div>
						</div>
					</div>
					<div class="form-control">
						<div class="flex w-full flex-col gap-1" x-on:keydown="handleKeydownOnOptions($event)" x-on:keydown.esc.window="isOpen = false, openedWithKeyboard = false" x-init="options = allOptions">
							<div class="relative">
								<input
									type="text"
									class="input input-bordered w-full disabled:cursor-not-allowed disabled:opacity-75 "
									name="ownerSearch"
									aria-label="Add event owners (search by name, organization, or email)"
									@input.throttle="fetchUsers($event.target.value)"
									x-ref="ownerSearch"
									placeholder="Add event owners (search by name, organization, or email)"
									class="input input-bordered"
									role="combobox"
									aria-controls="ownersList"
									aria-haspopup="listbox"
									x-on:click="isOpen = ! isOpen"
									x-on:keydown.down.prevent="
								isOpen = true;
								openedWithKeyboard = true;
								$nextTick(() => {
									$el.closest('.relative').querySelector('li[role=option]')?.focus()
								})"
									x-bind:aria-expanded="isOpen || openedWithKeyboard"
									autocomplete="new-password"
									:disabled="saveReqInFlight"
								/>
								<div
									x-show="isOpen || openedWithKeyboard"
									:class="{'opacity-100': isOpen || openedWithKeyboard}"
									class="w-full opacity-0 transition-all absolute left-0 top-12 z-50 overflow-hidden rounded-md border border-slate-300 bg-slate-100"
									id="ownersList"
									role="listbox"
									aria-label="event owners list"
									x-on:click.outside="isOpen = false, openedWithKeyboard = false"
									x-on:keydown.down.prevent="$focus.wrap().next()"
									x-on:keydown.up.prevent="
								if ($el.querySelector('li:focus') === $refs.optionsList.querySelector('li[role=option]')) {
									isOpen = false;
									openedWithKeyboard = false;
									$nextTick(() => {
											document.querySelector('[x-ref=ownerSearch]').focus();
									});
								} else {
										$focus.wrap().previous()
								}
							"
									x-transition
									x-trap="openedWithKeyboard"
								>
									<!-- Options  -->
									<ul x-ref="optionsList" class="flex max-h-44 flex-col overflow-y-auto">
										<template x-if="options?.length < 1">
											<li class="px-4 py-2 text-sm text-slate-700 dark:text-slate-300" x-ref="noResultsMessage">
												<span>No matches found</span>
											</li>
										</template>
										<template x-for="(item, index) in options" :key="index">
											<li
												class="combobox-option inline-flex cursor-pointer justify-between gap-6 bg-slate-100 px-4 py-2 text-sm text-slate-700 hover:bg-slate-800/5 hover:text-black focus-visible:bg-slate-800/5 focus-visible:text-black focus-visible:outline-none dark:bg-slate-800 dark:text-slate-300 dark:hover:bg-slate-100/5 dark:hover:text-white dark:focus-visible:bg-slate-100/10 dark:focus-visible:text-white"
												role="option"
												@click="setSelectedOwner(item)"
												@keydown.enter="setSelectedOwner(item)"
												:id="'option-' + index"
												tabindex="0"
											>
												<span x-text="item.label"></span>
											</li>
										</template>
									</ul>
								</div>
							</div>
						</div>
					</div>
					<h2 class="text-2xl mt-4">Related Events</h2>
					<div class="form-control w-full">
						<label class="label cursor-pointer">
							<span class="label-text">Only show my events as recommendations</span>
							<input
								name="hideCrossPromo"
								type="checkbox"
								class="toggle toggle-primary"
								x-model.fill="formData.event.hideCrossPromo"
								if event.HideCrossPromo {
									checked
								}
								:disabled="saveReqInFlight"
							/>
						</label>
					</div>
				</div>
			</div>
			<h2 class="text-2xl sticky sticky-under-top-nav subheader bg-base-100 z-40 py-2">Competition</h2>
			<div id="basic" class="card border-2 border-base-300 bg-base-200 p-4 md:p-10 rounded-box mb-4">
				<input
					disabled
					type="hidden"
					name="competitionConfigId"
					value={ event.CompetitionConfigId }
					x-model.fill="formData.event.competitionConfigId"
				/>
				if !isCompetitionAdmin {
					<div>
						<p>Only competition admins can modify competition config settings</p>
					</div>
				} else {
					<template x-if="formData.event?.competitionConfigId">
						<div class="form-control">
							<a class="link link-primary" :href="'/admin/competition/' + formData.event.competitionConfigId + '/edit' ">
								View Competition Config
							</a>
							<template x-if="formData.event?.competitionConfigId && !competitionRoundsLoaded">
								<div class="flex justify-between items-center">
									<div>Loading competition rounds...</div>
									<span class="loading loading-spinner loading-sm"></span>
								</div>
							</template>
							<template x-if="formData.event?.competitionConfigId && competitionRoundsLoaded">
								<template x-for="(competitionRound, index) in formData.event.competitionRounds">
									<div class="flex justify-between items-center">
										<div x-text=" (index + 1) + '. ' + competitionRound.roundName"></div>
										<button
											@click="handleRemoveCompetitionRoundFromEvent(competitionRound)"
											class="btn btn-ghost btn-circle btn-sm"
											:disabled="competitionRound.isRemoving || saveReqInFlight"
											aria-label="remove this competition round from event"
										>
											<template x-if="!competitionRound.isRemoving">
												<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
													<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
												</svg>
											</template>
											<template x-if="competitionRound.isRemoving">
												<span class="loading loading-spinner loading-sm"></span>
											</template>
										</button>
									</div>
								</template>
							</template>
						</div>
					</template>
					<div class="form-control">
						<button @click="addCompetition(formData.event)" class="btn btn-primary">
							<svg class="w-6 h-6 flex-none shrink-0 grow-0 fill-current" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6 13h-5v5h-2v-5h-5v-2h5v-5h2v5h5v2z"></path></svg>
							&nbsp;Add Competition
						</button>
					</div>
				}
			</div>
			<h2 class="text-2xl sticky sticky-under-top-nav subheader bg-base-100 z-40 py-2">Date &amp; Media</h2>
			<div id="basic" class="card border-2 border-base-300 bg-base-200 p-4 md:p-10 rounded-box mb-4">
				<div class="form-control">
					<label class="label">{ helpers.GetFieldDisplayName("StartTime") }</label>
					<input
						class="input input-bordered"
						type="datetime-local"
						x-model.fill={ "formData.event.startTime" }
						if (event.StartTime > 0) {
							value={ helpers.GetDatetimePickerFormatted(event.StartTime, &event.Timezone) }
						}
						:disabled="saveReqInFlight"
					/>
				</div>
				<div class="form-control">
					<label class="label">{ helpers.GetFieldDisplayName("EndTime") }</label>
					<input
						class="input input-bordered"
						type="datetime-local"
						x-model.fill={ "formData.event.endTime" }
						if (event.EndTime > 0) {
							value={ helpers.GetDatetimePickerFormatted(event.EndTime, &event.Timezone) }
						}
						:disabled="saveReqInFlight"
					/>
				</div>
				<div class="form-control">
					<label class="label">Timezone</label>
					<select
						class="select select-bordered"
						x-model.fill={ "formData.event.timezone" }
						value={ event.Timezone.String() }
						:disabled="saveReqInFlight"
					>
						<option value="">Select timezone</option>
						<option
							if (event.Timezone.String() == "America/New_York") {
								selected
							}
							value="America/New_York"
						>America/New_York</option>
						<option
							if (event.Timezone.String() == "America/Chicago") {
								selected
							}
							value="America/Chicago"
						>America/Chicago</option>
						<option
							if (event.Timezone.String() == "America/Denver") {
								selected
							}
							value="America/Denver"
						>America/Denver</option>
						<option
							if (event.Timezone.String() == "America/Los_Angeles") {
								selected
							}
							value="America/Los_Angeles"
						>America/Los_Angeles</option>
					</select>
				</div>
			</div>
			<h2 class="text-2xl sticky sticky-under-top-nav subheader bg-base-100 z-40 py-2">Event Series</h2>
			<div id="basic" class="card border-2 border-base-300 bg-base-200 p-4 md:p-10 rounded-box mb-4">
				<div class="card">
					<label class="label cursor-pointer">
						<span class="label-text">Enable Multi-Event Series</span>
						<div>
							<input
								name="isEventSeries"
								type="checkbox"
								class="toggle toggle-primary"
								x-model="isEventSeries"
								@change={ `formData.event.eventSourceType = isEventSeries ? "` + helpers.ES_SERIES_PARENT + `" : "` + helpers.ES_SINGLE_EVENT + `"` }
								if event.EventSourceType == helpers.ES_SERIES_PARENT || event.EventSourceType == helpers.ES_SERIES_PARENT_UNPUB {
									checked
								}
								:disabled="saveReqInFlight"
							/>
						</div>
					</label>
					<template x-if="isEventSeries">
						<div>
							if event.EventSourceType == helpers.ES_SERIES_PARENT || event.EventSourceType == helpers.ES_SERIES_PARENT_UNPUB {
								<div
									hx-get={ "/api/html/event-series-form/" + event.Id + "?&event_source_ids=" + event.Id + "&event_source_types=" + helpers.ES_EVENT_SERIES + "," + helpers.ES_EVENT_SERIES_UNPUB + "&start_time=" + helpers.GetDatetimePickerFormatted(0, &event.Timezone) + ":00Z" + "&end_time=" + helpers.GetDatetimePickerFormatted(helpers.DEFAULT_UNDEFINED_END_TIME, &event.Timezone) + ":00Z" }
									hx-trigger="load"
									hx-swap="outerHTML"
									@htmx:after-request="setEventChildrenLoaded()"
								>
									// TODO: add htmx response callback behavior to set eventChildrenLoaded to true
									<template x-if="!eventChildrenLoaded && formData.eventChildren.length < 1">
										<div class="flex w-full flex-col gap-4 my-3">
											<div class="skeleton h-4 w-1/2"></div>
											<div class="skeleton h-4 w-full"></div>
											<div class="skeleton h-4 w-full"></div>
										</div>
									</template>
								</div>
							}
							<div>
								<template x-for="(child, idx) in formData.eventChildren" :key="child.id">
									<div
										x-ref="childContainer"
										x-data="{ hidden: false, contentHeight: 0 }"
										x-init="contentHeight = $el.scrollHeight"
										@child-content-changed.window="$nextTick(() => contentHeight = $el.scrollHeight)"
										class="transition-all duration-300 ease-in-out bg-base-200"
										:class="hidden ? 'overflow-hidden' : '' "
										:style="hidden ? 'max-height: 0px' : `max-height: ${contentHeight}px`"
									>
										<div class="divider my-3"></div>
										<div class="flex justify-between items-center">
											<h3 x-text=" 'Event #' + (idx + 1) + ' in Series' "></h3>
											// NOTE: this hack addresses a bug where Alpine IDs are not stable
											// by default https://github.com/alpinejs/alpine/discussions/2325#discussioncomment-1599008
											<button
												@click="hidden = true; setTimeout(() => {
												const childIndex = formData.eventChildren.findIndex(evChild => evChild.id === child.id);
												if (childIndex !== -1) {
														formData.eventChildren.splice(childIndex, 1);
												}
											}, 200)"
												class="btn btn-ghost btn-circle btn-sm"
												:disabled="saveReqInFlight"
												aria-label="remove this event from series"
											>
												<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
													<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
												</svg>
											</button>
										</div>
										<div class="form-control">
											for _, diffField := range partials.AlwaysShowEventDiffFields {
												<label class="label">{ helpers.GetFieldDisplayName(diffField) }</label>
												<input
													class="input input-bordered w-full"
													type="datetime-local"
													name={ string(` 'event_' + idx + '_' + ` + string(diffField[0])) }
													x-model={ "formData.eventChildren[idx]." + strings.ToLower(string(diffField[0])) + diffField[1:] }
												/>
											}
										</div>
										<template x-if="child.competitionConfigId">
											<div class="form-control">
												<label class="label">Competition Config</label>
												<a class="link link-primary" :href="'/admin/competition/' + child.competitionConfigId + '/edit' ">
													View Competition Config
												</a>
												<input disabled type="hidden" name="competitionConfigId" x-model.fill="child.competitionConfigId"/>
												<template x-if="child?.competitionConfigId && !competitionRoundsLoaded">
													<div class="flex justify-between items-center">
														<div>Loading competition rounds...</div>
														<span class="loading loading-spinner loading-sm"></span>
													</div>
												</template>
												<template x-if="child?.competitionConfigId && competitionRoundsLoaded">
													<template x-for="(competitionRound, index) in child.competitionRounds">
														<div class="flex justify-between items-center">
															<div x-text=" (index + 1) + '. ' + competitionRound.roundName"></div>
															<button
																@click="handleRemoveCompetitionRoundFromEvent(competitionRound)"
																class="btn btn-ghost btn-circle btn-sm"
																:disabled="competitionRound.isRemoving || saveReqInFlight"
																aria-label="remove this competition round from event"
															>
																<template x-if="!competitionRound.isRemoving">
																	<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
																		<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
																	</svg>
																</template>
																<template x-if="competitionRound.isRemoving">
																	<span class="loading loading-spinner loading-sm"></span>
																</template>
															</button>
														</div>
													</template>
												</template>
											</div>
										</template>
										<div class="dropdown">
											<div tabindex="0" role="button" class="btn btn-outline m-1 mt-2">
												Override Parent Event
											</div>
											<ul tabindex="0" class="dropdown-content menu bg-base-100 rounded-box z-[1] w-52 p-2 shadow">
												<li>
													<a @click="addCompetition(child)">
														<svg class="w-6 h-6 flex-none shrink-0 grow-0 fill-current" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6 13h-5v5h-2v-5h-5v-2h5v-5h2v5h5v2z"></path></svg>
														&nbsp;Add Competition
													</a>
												</li>
											</ul>
										</div>
									</div>
								</template>
							</div>
							<button class="btn btn-primary mt-3 w-full" @click="addNewEventChild()" :disabled="saveReqInFlight">
								<svg class="w-6 h-6 flex-none shrink-0 grow-0 fill-current" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6 13h-5v5h-2v-5h-5v-2h5v-5h2v5h5v2z"></path></svg>
								Add New Event
							</button>
						</div>
					</template>
				</div>
			</div>
			<h2 class="text-2xl sticky sticky-under-top-nav subheader bg-base-100 z-40 py-2">Location</h2>
			<div id="location" class="card border-2 border-base-300 bg-base-200 p-4 md:p-10 rounded-box mb-4">
				<div class="card">
					@components.LocationLookupPartial("post", "/api/location/geo", "", "formData.url", "Confirm Address", "Address Confirmed", event.Lat, event.Long, event.Address, cfLocationLat, cfLocationLon)
				</div>
			</div>
			<h2 class="text-2xl sticky sticky-under-top-nav subheader bg-base-100 z-40 py-2">Tickets, Sales, & Registrations</h2>
			<div id="pricing" class="card border-2 border-base-300 bg-base-200 p-4 md:p-10 rounded-box mb-4">
				<div class="card">
					<h3 class="text-xl">Registration</h3>
					<div class="form-control w-full">
						<label class="label cursor-pointer">
							<span class="label-text">Enable Event Registration (collect attendee question responses)</span>
							<input
								name="hasRegistrationFields"
								type="checkbox"
								class="toggle toggle-primary"
								x-model.fill="formData.event.hasRegistrationFields"
								if event.HasRegistrationFields {
									checked
								}
								:disabled="saveReqInFlight"
							/>
						</label>
					</div>
					<template x-if="formData.event.hasRegistrationFields && !registrationFieldsLoaded && registrationFields.length < 1">
						<div class="mt-2"><span class="loading loading-spinner loading-md text-primary"></span></div>
					</template>
					<template x-if="formData.event.hasRegistrationFields">
						<div class="registration-fields-manager">
							<div class="flex justify-between items-center mb-4 mt-8">
								<h4 class="text-xl">Registration Fields</h4>
							</div>
							<ul x-sort="($item, $position) => handleRegFieldReorder($item, $position, $el)" class="space-y-4">
								<template x-for="(field, index) in registrationFields" :key="field.id + '-' + field.order">
									<li x-sort:item="field.id" class="card bg-base-100 shadow-md p-4">
										<div class="flex items-center gap-2 mb-4">
											<span x-sort:handle class="cursor-move">
												<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
													<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8h16M4 16h16"></path>
												</svg>
											</span>
											<button
												@click="removeField(index)"
												class="btn btn-ghost btn-circle btn-sm ml-auto"
												:disabled="saveReqInFlight"
											>
												<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
													<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
												</svg>
											</button>
										</div>
										<div class="grid grid-cols-1 md:grid-cols-2 gap-4">
											<div class="form-control">
												<label class="label">Field Name</label>
												<input
													type="text"
													class="input input-bordered"
													x-model="field.name"
													:disabled="saveReqInFlight"
												/>
											</div>
											<div class="form-control">
												<label class="label">Field Type</label>
												<select
													class="select select-bordered"
													x-model="field.type"
													@change="handleTypeChange($event, index)"
													:disabled="saveReqInFlight"
												>
													<option value="text">Text</option>
													<option value="checkbox">Checkbox</option>
													<option value="select">Select</option>
												</select>
											</div>
											<div class="form-control md:col-span-2">
												<div class="flex flex-col items-start">
													<label class="label cursor-pointer">
														<span class="label-text">Required Field</span>
														<input
															type="checkbox"
															class="toggle toggle-primary ml-4"
															x-model="field.required"
															:disabled="saveReqInFlight"
														/>
													</label>
												</div>
											</div>
											<template x-if="field.type === 'select'">
												<div class="form-control md:col-span-2">
													<label class="label">Options (one per line)</label>
													<textarea
														class="textarea textarea-bordered"
														x-model="field.optionsText"
														@input="updateOptions(index)"
														:disabled="saveReqInFlight"
													></textarea>
												</div>
											</template>
											<div class="form-control">
												<label class="label">Default Value</label>
												<input
													type="text"
													class="input input-bordered"
													x-model="field.default"
													:disabled="saveReqInFlight"
												/>
											</div>
											<div class="form-control">
												<label class="label">Placeholder</label>
												<input
													type="text"
													class="input input-bordered"
													x-model="field.placeholder"
													:disabled="saveReqInFlight"
												/>
											</div>
											<div class="form-control md:col-span-2">
												<label class="label">Description</label>
												<textarea
													class="textarea textarea-bordered"
													x-model="field.description"
													:disabled="saveReqInFlight"
												></textarea>
											</div>
										</div>
									</li>
								</template>
							</ul>
							<button
								@click="addRegistrationField()"
								class="btn btn-primary mt-3 mb-8 w-full"
								:disabled="saveReqInFlight"
							>
								<svg class="w-6 h-6 flex-none shrink-0 grow-0 fill-current" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6 13h-5v5h-2v-5h-5v-2h5v-5h2v5h5v2z"></path></svg>
								Add Registration Field
							</button>
						</div>
					</template>
					<h3 class="text-xl mt-4">Purchasable Items, Tickets, Merch, etc.</h3>
					<div class="form-control w-full">
						<label class="label cursor-pointer">
							<span class="label-text">Enable Purchasable Items</span>
							<input
								name="hasPurchasable"
								type="checkbox"
								class="toggle toggle-primary"
								x-model.fill="formData.event.hasPurchasable"
								if event.HasPurchasable {
									checked
								}
								:disabled="saveReqInFlight"
							/>
						</label>
					</div>
					<template x-if="formData.event.hasPurchasable">
						<div>
							<template x-if="formData.event.hasPurchasable && !purchasablesLoaded && purchasables.length < 1">
								<div class="mt-2"><span class="loading loading-spinner loading-md text-primary"></span></div>
							</template>
							<template x-if="purchasables.length > 0">
								<ul x-sort="($item, $position) => handlePurchasableOrder($item, $position)" class="list-none p-0">
									<template x-for="(purchasable, index) in purchasables" :key="purchasable.id + '-' + purchasable.order">
										<li x-sort:item="purchasable.id" class="card bg-base-100 shadow-md p-4 mt-4">
											<div class="flex items-center gap-2 mb-4">
												<span x-sort:handle class="cursor-move">
													<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
														<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8h16M4 16h16"></path>
													</svg>
												</span>
												<button
													@click="removePurchasable(index)"
													class="btn btn-ghost btn-circle btn-sm ml-auto"
													:disabled="saveReqInFlight"
												>
													<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
														<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
													</svg>
												</button>
											</div>
											<div class="grid grid-cols-1 md:grid-cols-2 gap-4">
												<!-- Name -->
												<div class="form-control">
													<label class="label">Name</label>
													<input
														type="text"
														class="input input-bordered"
														x-model="purchasable.name"
													/>
												</div>
												<!-- Item Type -->
												<div class="form-control">
													<label class="label">Item Type</label>
													<select class="select select-bordered" x-model="purchasable.item_type">
														<option value="ticket">Ticket</option>
														<option value="merchandise">Merchandise</option>
													</select>
												</div>
												<!-- Cost with currency formatting -->
												<div class="form-control">
													<label class="label">Cost</label>
													<input
														class="input input-bordered"
														x-mask:dynamic="$money($input)"
														x-model="purchasable.cost"
													/>
												</div>
												<!-- Registration Fields Multi-select -->
												<div class="form-control md:col-span-2 mt-8">
													<label class="label">Registration Fields</label>
													<div class="flex flex-wrap gap-2">
														<ul
															x-sort="($item, $position) => handlePurchasableRegFieldReorder($item, $position, purchasable)"
															class="flex flex-wrap gap-2"
														>
															<template
																x-for="(fieldName, index) in purchasable.registration_fields"
																:key="fieldName + '-' + index"
															>
																<li
																	x-sort:item="fieldName"
																	class="label cursor-pointer inline-flex items-center gap-2 bg-base-200 px-3 py-1 rounded-full"
																>
																	<span x-sort:handle class="cursor-move mr-1">
																		<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
																			<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8h16M4 16h16"></path>
																		</svg>
																	</span>
																	<input
																		type="checkbox"
																		class="checkbox checkbox-sm"
																		checked
																		@change="purchasable.registration_fields = purchasable.registration_fields.filter(f => f !== fieldName)"
																	/>
																	<span x-text="fieldName"></span>
																</li>
															</template>
														</ul>
														<!-- Available fields that aren't selected yet -->
														<template x-for="field in registrationFields.filter(f => !purchasable.registration_fields.includes(f.name))" :key="field.id">
															<label class="label cursor-pointer inline-flex items-center gap-2 px-3 py-1 rounded-full">
																<input
																	type="checkbox"
																	class="checkbox checkbox-sm"
																	@change="purchasable.registration_fields.push(field.name)"
																/>
																<span x-text="field.name"></span>
															</label>
														</template>
													</div>
												</div>
												<!-- Expires On -->
												<div class="form-control">
													<label class="label">Expires On</label>
													<input
														type="datetime-local"
														class="input input-bordered"
														x-model="purchasable.expires_on"
													/>
												</div>
												<div class="form-control">
													<label class="label">Inventory</label>
													<input
														type="number"
														class="input input-bordered"
														x-model="purchasable.inventory"
														@input="purchasable.inventory = parseInt($event.target.value || 0)"
													/>
												</div>
												<div class="form-control">
													<label class="label">Starting Quantity</label>
													<input
														type="number"
														class="input input-bordered"
														x-model="purchasable.starting_quantity"
														@input="purchasable.starting_quantity = parseInt($event.target.value || 0)"
													/>
												</div>
											</div>
										</li>
									</template>
								</ul>
							</template>
							<button
								@click="addPurchasable()"
								class="btn btn-primary mt-3 mb-8 w-full"
								:disabled="saveReqInFlight"
							>
								<svg class="w-6 h-6 flex-none shrink-0 grow-0 fill-current" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6 13h-5v5h-2v-5h-5v-2h5v-5h2v5h5v2z"></path></svg>
								Add Purchasable Item
							</button>
						</div>
					</template>
					<div :class="formData.event.hasPurchasable ? 'grid grid-2' : 'hidden'">
						<div class="form-control">
							<label class="label">Starting Price</label>
							<input
								class="input"
								placeholder="Enter starting price"
								x-model.fill={ "formData.event.startingPrice" }
								x-mask:dynamic="$money($input)"
								if event.StartingPrice > 0 {
									value={ strconv.FormatFloat(float64(event.StartingPrice)/100.0, 'f', 2, 64) }
								}
							/>
						</div>
						<div class="form-control">
							<label class="label">Currency</label>
							<select class="select" value={ event.Currency }>
								<option value="">Select currency</option>
								<option
									value="USD"
									x-model.fill={ "formData.event.currency" }
									if event.Currency == "USD" {
										selected
									}
								>USD</option>
								<option
									value="CAD"
									disabled
									if event.Currency == "CAD" {
										selected
									}
								>CAD</option>
								<option
									value="EUR"
									disabled
									if event.Currency == "EUR" {
										selected
									}
								>EUR</option>
								<option
									value="GBP"
									disabled
									if event.Currency == "GBP" {
										selected
									}
								>GBP</option>
							</select>
						</div>
						<div class="form-control">
							// TODO: make this a typeahead like other user lookup for event owners
							<label class="label">Payee (user id)</label>
							<input
								class="input"
								type="text"
								x-model="formData.event.payeeId"
								value={ event.PayeeId }
								:disabled="saveReqInFlight"
							/>
						</div>
					</div>
				</div>
			</div>
			// <dialog id="add-competition-modal" class="modal modal-bottom sm:modal-middle bg-base-200 bg-opacity-90">
			// 	<div class="modal-box">
			// 		<h3 class="text-lg font-bold">YAY!</h3>
			// 		<p class="py-4">We've noted your interest, sorry to miss you... but next time!</p>
			// 		<form method="dialog" class="modal-backdrop">
			// 			<!-- if there is a button in form, it will close the modal -->
			// 			<button class="btn btn-primary">Close</button>
			// 		</form>
			// 	</div>
			// </dialog>
			<dialog id="add-competition-modal" class="modal modal-bottom sm:modal-middle bg-base-200 bg-opacity-90">
				<div class="modal-box">
					<h3 class="text-lg font-bold">Add Competition to Event</h3>
					<p class="py-4">Choose a competition to add to this event</p>
					<select x-model="competitionModalCompetitionSelection" class="select select-bordered" @change="handleCompetitionSelection(competitionModalCompetitionSelection)">
						<option value="">Select a competition</option>
						<template x-for="competition in competitionConfigs">
							<option :value="competition.id"><span x-text="competition.name"></span></option>
						</template>
					</select>
					<template x-if="competitionModalCompetitionSelection">
						<div>
							<h3 class="text-lg font-bold my-4">Add Rounds to this Event</h3>
							<p class="py-4">Choose rounds to add to this event</p>
							<template x-if="competitionModalRoundsLoading">
								<div>
									Loading rounds...
									<span class="loading loading-spinner loading-sm"></span>
								</div>
							</template>
							<template x-if="competitionModalRounds.length > 0">
								<div class="space-y-2">
									<template x-for="round in competitionModalRounds" :key="round.roundNumber">
										<div class="form-control">
											<label class="flex items-center gap-2 cursor-pointer">
												<input
													type="checkbox"
													class="checkbox my-2"
													:value="round.roundNumber"
													x-model="competitionModalRoundSelections"
												/>
												<span x-text="round.roundName"></span>
											</label>
										</div>
									</template>
								</div>
							</template>
							<button class="btn btn-primary mt-4" @click="handleAddRoundClick()">
								Add Selected Rounds
								<template x-if="saveReqInFlight">
									<span class="loading loading-spinner loading-sm"></span>
								</template>
							</button>
						</div>
					</template>
				</div>
				<form method="dialog" class="modal-backdrop">
					<button>close</button>
				</form>
			</dialog>
			<div class="sticky bottom-0 flex justify-end border-2 border-base-300 bg-base-200 py-4 z-50">
				// <button class="btn btn-outline">Cancel</button>
				<button :disabled="saveReqInFlight" @click="handlePublishClick()" class="btn btn-primary mx-4">
					<template x-if="publishStatus?.endsWith?.(unpubSuffix)">
						<span>Save as Draft</span>
					</template>
					<template x-if="!publishStatus?.endsWith?.(unpubSuffix)">
						<span>Publish</span>
					</template>
					<template x-if="saveReqInFlight">
						<span class="loading loading-spinner loading-sm"></span>
					</template>
				</button>
			</div>
			<template x-if="showToast === true">
				<div class="toast m-4 z-50 ">
					<div :class="toastContent.type == 'error' ? 'alert-error' : 'alert-success'" class="alert  border-2 border-base-300">
						<span x-text="toastContent.message"></span>
						<div class="block justify-end">
							<button class="btn btn-sm btn-circle btn-ghost text-2xl float-end" @click="showToast = false"><svg class="svg-icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"><path d="M777.856 280.192l-33.92-33.952-231.872 231.872-231.84-231.872-33.984 33.888 231.872 231.904-231.84 231.84 33.888 33.984 231.904-231.904 231.84 231.872 33.952-33.888-231.872-231.904z"></path></svg></button>
						</div>
					</div>
				</div>
			</template>
		</div>
		<script id="add-edit-event" data-event-id={ event.Id } data-event-owners={ string(helpers.ToJSON(event.EventOwners)) } data-event-owner-name={ event.EventOwnerName } data-event-owner-delimiter={ helpers.EventOwnerNameDelimiter } data-event-tags={ string(helpers.ToJSON(event.Tags)) } data-event-categories={ string(helpers.ToJSON(event.Categories)) } data-event-type-single={ helpers.ES_SINGLE_EVENT } data-event-type-series-parent={ helpers.ES_SERIES_PARENT } data-event-type-series-child={ helpers.ES_EVENT_SERIES } data-event-lat={ strconv.FormatFloat(event.Lat, 'f', -1, 64) } data-event-long={ strconv.FormatFloat(event.Long, 'f', -1, 64) } data-event-address={ event.Address } data-event-source-id={ event.EventSourceId } data-payee-id={ event.PayeeId } data-event-hide-cross-promo={ strconv.FormatBool(event.HideCrossPromo) } data-event-detail-url={ strings.Replace(strings.Replace(helpers.SitePages["event-detail"].Slug, helpers.EVENT_ID_KEY, "", 1), "{trailingslash:\\/?}", "", 1) } data-competition-config-id={ event.CompetitionConfigId } data-is-competition-admin={ strconv.FormatBool(isCompetitionAdmin) } data-round-empty-event-id={ helpers.COMP_UNASSIGNED_ROUND_EVENT_ID } data-unpub-suffix={ helpers.UNPUB_SUFFIX } data-published-suffix={ helpers.PUBLISHED_SUFFIX }>

	function getAddEditEventState() {
		return {
					init() {
						(async () => {
								const ownerNames = this.formData.event.eventOwnerName.split(this.eventOwnerDelimiter);
								const ownerIds = JSON.parse(document.querySelector('#add-edit-event').getAttribute('data-event-owners')) ?? []
								this.owners = ownerIds.map((ownerId, idx) => {
									return { label: ownerNames?.[idx], value: ownerId };
								});
								this.allOptions = this.owners

								if (this.formData.event.hasPurchasable) {
									try {
										const purchasablesResponse = await fetch(`/api/purchasables/${this.formData.event.id}`);
										const purchasables = await purchasablesResponse.json();
										this.purchasables = purchasables?.purchasable_items ?? [];
										this.purchasables = this.purchasables.map(p => ({
											...p,
											id: crypto.randomUUID(),
											cost: (p.cost / 100).toFixed(2),
											registration_fields: p.registration_fields || [],
											currency: this.formData.event.currency,
											expires_on: p.expires_on?.replace(this.timeZuluSuffix, '') ?? null
										}));
										this.purchasablesCreatedAt = purchasables?.created_at ?? '';
										this.purchasablesLoaded = true;
									} catch (error) {
										// eslint-disable-next-line no-console
										console.error('Failed to fetch purchasables:', error);
										this.showToast = true;
										this.toastContent = {
											type: 'error',
											message: 'Failed to fetch purchasables',
										}
									}
								} else {
									this.purchasables = [];
									this.purchasablesLoaded = true;
								}

								if (this.formData.event.hasRegistrationFields) {
									try {
										const registrationFieldsResponse = await fetch(`/api/registration-fields/${this.formData.event.id}`);
										const registrationFields = await registrationFieldsResponse.json();
										this.registrationFields = registrationFields?.fields.map((field, index) => ({
											...field,
											optionsText: field.options ? field.options.join('\n') : '',
											order: index,
											id: field.id ?? crypto.randomUUID(),
										})) ?? [];
										this.registrationFieldsCreatedAt = registrationFields?.created_at ?? '';
										this.registrationFieldsLoaded = true;
									} catch (error) {
										// eslint-disable-next-line no-console
										console.error('Failed to fetch registration fields:', error);
										this.showToast = true;
										this.toastContent = {
											type: 'error',
											message: `Failed to fetch registration fields: ${error.message}`,
										}
									}
								} else {
									this.registrationFields = [];
									this.registrationFieldsLoaded = true;
								}

								if (this.isCompetitionAdmin) {
									await fetch(`/api/competition-config/owner`).then(res => {
										return res.json()
									}).then(json => {
										this.competitionConfigs = json
									});
								}

								try {

										// Wait for eventChildrenLoaded using a Promise, but skip if not an event series
										if (this.isEventSeries) {
											await new Promise((resolve) => {
													const checkLoaded = () => {
														if (this.eventChildrenLoaded) {
																	resolve();
															} else {
																	setTimeout(checkLoaded, 100);
															}
													};
													checkLoaded();
											});
										}

										const allEvents = [this.formData.event, ...Object.values(this.formData.eventChildren)]
										const competitionIdsToFetch = []
										const promises = []
										allEvents.forEach(event => {
											if (event.competitionConfigId) {
												competitionIdsToFetch.push(event.competitionConfigId)
											}
										})

										competitionIdsToFetch.forEach(competitionId => {
											promises.push(fetch(`/api/competition-round/competition/${competitionId}`))
										})
										this.competitionRoundsLoaded = false
										const roundResponses = await Promise.all(promises)
										const roundData = await Promise.all(roundResponses.map(r => r.json()))
										// Flatten the array of round data arrays
										const flattenedRoundData = roundData.flat()
										flattenedRoundData.forEach(round => {
												// Check parent event first
												if (this.formData.event.id === round.eventId) {
														if (!this.formData.event.competitionRounds) {
																this.formData.event.competitionRounds = [];
														}
														this.formData.event.competitionRounds.push(round);
												} else {
														// Check children events
														const childIndex = this.formData.eventChildren.findIndex(
																child => child.id === round.eventId
														);
														if (childIndex !== -1) {
																// instantiate if empty, otherwise keep the existing array
																// this.formData.eventChildren[childIndex].competitionRounds = this.formData.eventChildren[childIndex]?.competitionRounds || []
																// this.formData.eventChildren[childIndex].competitionRounds.push(round);
																if (!this.formData.eventChildren[childIndex]?.competitionRounds?.find?.(r => r.roundNumber === round.roundNumber)) {
																	if (!Array.isArray(this.formData.eventChildren[childIndex]?.competitionRounds)) {
																		this.formData.eventChildren[childIndex].competitionRounds = []
																	}
																	this.formData.eventChildren[childIndex].competitionRounds.push(round);
																}
														}
												}
										});


										this.competitionRoundsLoaded = true
										this.$nextTick(() => {
											// Dispatch event to trigger event child height recalculation
											window.dispatchEvent(new CustomEvent('child-content-changed'));
										});
								} catch (error) {
									// eslint-disable-next-line no-console
									console.error('Error fetching event children:', error);
								}
						})()
					},
					formData: {
						pendingRoundUpdates: [], // store rounds that need to be updated or published
						eventChildren: [],
						event: {
							competitionConfigId: document.querySelector('#add-edit-event').getAttribute('data-competition-config-id') ?? null,
							id: document.querySelector('#add-edit-event').getAttribute('data-event-id') ?? null,
							eventSourceId: document.querySelector('#add-edit-event').getAttribute('data-event-source-id') ?? null,
							eventOwners: JSON.parse(document.querySelector('#add-edit-event').getAttribute('data-event-owners')) ?? [],
							eventOwnerName: document.querySelector('#add-edit-event').getAttribute('data-event-owner-name') ?? '',
							eventSourceType: document.querySelector('[name=isEventSeries]').checked ? document.querySelector("#add-edit-event").getAttribute('data-event-type-series-parent') : document.querySelector("#add-edit-event").getAttribute('data-event-type-single'),
							tags: JSON.parse(document.querySelector('#add-edit-event').getAttribute('data-event-tags')) ?? [],
							categories: JSON.parse(document.querySelector('#add-edit-event').getAttribute('data-event-categories')) ?? [],
							hasPurchasable: document.querySelector('[name=hasPurchasable]').checked ?? false,
							payeeId: document.querySelector('#add-edit-event').getAttribute('data-payee-id') ?? null,
							hasRegistrationFields: document.querySelector('[name=hasRegistrationFields]').checked ?? false,
							lat: document.querySelector('#add-edit-event').getAttribute('data-event-lat') ?? null,
							long: document.querySelector('#add-edit-event').getAttribute('data-event-long') ?? null,
							address: document.querySelector('#add-edit-event').getAttribute('data-event-address') ?? null,
							hideCrossPromo: document.querySelector('[name=hideCrossPromo]').checked ?? false,
						},
					},
					publishStatus: document.querySelector('#publishStatus')?.value ?? null,
					isCompetitionAdmin: document.querySelector('#add-edit-event').getAttribute('data-is-competition-admin') ?? false,
					emptyRoundEventId: document.querySelector('#add-edit-event').getAttribute('data-round-empty-event-id') ?? null,
					competitionConfigs: [],
					competitionModalIndex: null,
					competitionModalEventSelection: null,
					competitionModalCompetitionSelection: null,
					competitionModalRounds: [],
					competitionModalRoundsLoading: false,
					competitionRoundsLoaded: false,
					competitionModalRoundSelections: [],
					eventDetailUrl: document.querySelector('#add-edit-event').getAttribute('data-event-detail-url') ?? null,
					eventChildrenLoaded: false,
					purchasablesLoaded: false,
					purchasablesCreatedAt: '',
					registrationFieldsLoaded: false,
					registrationFieldsCreatedAt: '',
					purchasables: [],
					registrationFields: [],
					owners: [],
					isEventSeries: document.querySelector('[name=isEventSeries]')?.checked ?? false,
					categoryInput: '',
					tagInput: '',
					ownerInput: '',
					saveReqInFlight: false,
					showToast: false,
					toastContent: {
						type: '',
						message: ' updated successfully',
					},
					eventOwnerDelimiter: document.querySelector('#add-edit-event').getAttribute('data-event-owner-delimiter'),
					eventTypeSingleConstant: document.querySelector("#add-edit-event").getAttribute('data-event-type-single'),
					eventTypeSeriesParentConstant: document.querySelector("#add-edit-event").getAttribute('data-event-type-series-parent'),
					eventTypeSeriesChildConstant: document.querySelector("#add-edit-event").getAttribute('data-event-type-series-child'),
					unpubSuffix: document.querySelector("#add-edit-event").getAttribute('data-unpub-suffix'),
					publishedSuffix: document.querySelector("#add-edit-event").getAttribute('data-published-suffix'),
					// The API expects RFC3339 HH:MM:SS, but datetime-local is in HH:MM
					timeZuluSuffix: ":00Z",
					// BEGIN: Event Owners typeahead state
					allOptions: [],
					options: [],
					isOpen: false,
					openedWithKeyboard: false,
					async fetchUsers(query) {
						if (query.length >= 3) {
							await fetch(`/api/user-search?q=${query}`).then(res => {
								return res.json()
							}).then(json => {
								// Filter out users that are already owners
								const filteredUsers = json.filter(user =>
									!this.owners.some(owner => owner.value === user.userId)
								);
								this.options = filteredUsers.map((user) => ({
										label: user.displayName,
										value: user.userId,
								}))
								this.$nextTick(() => {
									this.isOpen = true
								})
							});
						}
					},
					removeOwner(ownerToRemove) {
							this.owners = this.owners.filter(owner => owner !== ownerToRemove);
					},
					setSelectedOwner(option) {
							this.isOpen = false
							this.owners.push(option);
							this.options = this.options.filter(o => o.value !== option.value)
							this.$nextTick(() => {
								document.querySelector('[x-ref=ownerSearch]').focus();
							})
					},
					handleKeydownOnOptions(event) {
							// if the user presses backspace or the alpha-numeric keys, focus on the search field
							if (/^[a-zA-Z0-9]$/.test(event.key) || event.key === 'Backspace') {
									this.$refs.ownerSearch.focus()
							}
					},

					// END: Event Owners typeahead helper functions

					addTag() {
							if (this.tagInput.trim() !== '') {
									this.formData.event.tags.push(this.tagInput.trim());
									this.tagInput = '';
							}
					},

					removeTag(tagToRemove) {
							this.formData.event.tags = this.formData.event.tags.filter(tag => tag !== tagToRemove);
					},

					handleTagKeydown(e) {
							if (e.key === 'Enter') {
									e.preventDefault();
									this.addTag();
							}
					},

					addCategory() {
							if (this.categoryInput.trim() !== '') {
									this.formData.event.categories.push(this.categoryInput.trim());
									this.categoryInput = '';
							}
					},

					removeCategory(categoryToRemove) {
							this.formData.event.categories = this.formData.event.categories.filter(category => category !== categoryToRemove);
					},

					handleCategoryKeydown(e) {
							if (e.key === 'Enter') {
									e.preventDefault();
									this.addCategory();
							}
					},
					addNewEventChild() {
						this.formData.eventChildren.push({
							startTime: '',
							endTime: '',
							id: crypto.randomUUID(),
						})
					},
					deriveEventSourceTypeFromDropdown(event, publishStatus, isEventSeries, isChild) {
						let sourceTypeSansSuffix = event.eventSourceType.replace(this.unpubSuffix, '').replace(this.publishedSuffix, '')
						if (isEventSeries && !isChild) {
							sourceTypeSansSuffix = this.eventTypeSeriesParentConstant
						} else if (isEventSeries && isChild) {
							sourceTypeSansSuffix = this.eventTypeSeriesChildConstant
						}
						// NOTE: for backwards compatibility, the suffix is only included for UNPUBLISHED events, published events lack a correlating suffix
						return publishStatus === this.publishedSuffix ? sourceTypeSansSuffix : sourceTypeSansSuffix + this.unpubSuffix
					},
					transformEventToPayload(event) {
						const _event = JSON.parse(JSON.stringify(event))
						const _eventFiltered = Object.fromEntries(
							Object.entries(_event)
								// eslint-disable-next-line no-unused-vars
								.filter(([_, value]) => value !== '')
						)
						if (!_event.hasPurchasable) {
							delete _eventFiltered.startingPrice
							delete _eventFiltered.currency
							delete _eventFiltered.payeeId
						}

						const _eventSourceType = this.deriveEventSourceTypeFromDropdown(event, this.publishStatus, this.isEventSeries, false)

						return {
							..._eventFiltered,
							startTime: this.formData.event.startTime ? this.formData.event.startTime + this.timeZuluSuffix : null,
							endTime: this.formData.event.endTime ? this.formData.event.endTime + this.timeZuluSuffix : null,
							lat: parseFloat(this.formData.event.lat),
							long: parseFloat(this.formData.event.long),
							eventSourceType: _eventSourceType,
							eventOwners: this.owners.map(owner => owner.value),
							eventOwnerName: this.owners.map(owner => owner.label).join(this.eventOwnerDelimiter),
							...(this.formData.event.hasPurchasable ? {
									startingPrice: this.formData.event.startingPrice * 100,
									currency: this.formData.event.currency,
									payeeId: this.formData.event.payeeId,
								} : {}
							),
						}
					},
					setEventChildrenLoaded() {
						this.eventChildrenLoaded = true
					},
					addRegistrationField() {
							this.registrationFields.push({
									id: crypto.randomUUID(), // Add unique ID
									order: this.registrationFields.length, // Add order tracking
									name: '',
									type: 'text',
									options: null,
									optionsText: '',
									default: '',
									placeholder: '',
									description: '',
									required: false
							});
					},
					removeField(index) {
						this.registrationFields.splice(index, 1);
					},

					handleTypeChange(event, index) {
						const type = event.target.value;
						if (type === 'select' && !this.registrationFields[index].options) {
							this.registrationFields[index].options = [];
							this.registrationFields[index].optionsText = '';
						} else if (type !== 'select') {
							this.registrationFields[index].options = null;
							this.registrationFields[index].optionsText = '';
						}
					},

					updateOptions(index) {
						const field = this.registrationFields[index];
						field.options = field.optionsText
							.split('\n')
							.map(option => option.trim())
							.filter(option => option !== '');
					},

					handleRegFieldReorder($item, $position) {
						// Create a POJO copy of the array
						let fields = this.registrationFields.map(f => ({...f}));

						// Find the moved item by ID
						const itemIndex = fields.findIndex(f => f.id === $item);
						if (itemIndex === -1) return;

						// Remove and reinsert at new position
						const [movedItem] = fields.splice(itemIndex, 1);
						fields.splice($position, 0, movedItem);

						// Update order values
						fields = fields.map((field, index) => ({
								...field,
								order: index
						}));

						// Update the array with the new order
						this.registrationFields = fields;

						// Force Alpine to recognize the change
						this.$nextTick(() => {
								const templateEl = this.$el.querySelector('template[x-for]');
								if (templateEl && templateEl.__x) {
										templateEl.__x._x_prevKeys = fields.map(f => `${f.id}-${f.order}`);
								}
						});
					},

					handleRegistrationFieldOrder($item, $position, purchasable) {
						// Create a new array to trigger reactivity
						let fields = [...purchasable.registration_fields];

						// Find the moved item
						const itemIndex = fields.indexOf($item);
						if (itemIndex === -1) return;

						// Remove and reinsert at new position
						const [movedItem] = fields.splice(itemIndex, 1);
						fields.splice($position, 0, movedItem);

						// Update the array
						purchasable.registration_fields = fields;
					},

					handlePurchasableOrder($item, $position) {
						// Create a POJO copy of the array
						let items = this.purchasables.map(p => ({...p}));

						// Find the moved item by ID
						const itemIndex = items.findIndex(p => p.id === $item);
						if (itemIndex === -1) return;

						// Remove and reinsert at new position
						const [movedItem] = items.splice(itemIndex, 1);
						items.splice($position, 0, movedItem);

						// Update order values
						items = items.map((item, index) => ({
							...item,
							order: index
						}));

						// Update the array with the new order
						this.purchasables = items;

						// Force Alpine to recognize the change
						this.$nextTick(() => {
							const templateEl = this.$el.querySelector('template[x-for]');
							if (templateEl && templateEl.__x) {
								templateEl.__x._x_prevKeys = items.map(p => `${p.id}-${p.order}`);
							}
						});
					},

					removePurchasable(index) {
						this.purchasables.splice(index, 1);
					},

					addPurchasable() {
						this.purchasables.push({
							id: crypto.randomUUID(),
							order: this.purchasables.length,
							name: '',
							item_type: 'ticket',
							cost: 0,
							inventory: 0,
							starting_quantity: 0,
							registration_fields: [],
							expires_on: null,
							currency: this.formData.event.currency
						});
					},

					handlePurchasableRegFieldReorder($item, $position, purchasable) {
						// Create POJO array of current fields with order
						let fields = purchasable.registration_fields.map((name, index) => ({
						name,
						order: index
					}));

					// Find the moved item
					const itemIndex = fields.findIndex(f => f.name === $item);
					if (itemIndex === -1) return;

					// Remove and reinsert at new position
					const [movedItem] = fields.splice(itemIndex, 1);
					fields.splice($position, 0, movedItem);

					// Update order values
					fields = fields.map((field, index) => ({
						...field,
						order: index
					}));

					// Update the array with just the names in the new order
					purchasable.registration_fields = fields.map(f => f.name);

					// Force Alpine to recognize the change
					this.$nextTick(() => {
						const templateEl = this.$el.querySelector('template[x-for]');
							if (templateEl && templateEl.__x) {
								templateEl.__x._x_prevKeys = fields.map(f => `${f.name}-${f.order}`);
							}
						});
					},

					addCompetition(event) {
						this.competitionModalEventSelection = event
						document.getElementById('add-competition-modal').showModal()
					},

					async handleCompetitionSelection(competitionId) {
						this.competitionModalCompetitionSelection = competitionId
						this.competitionModalRoundsLoading = true
						try {
							const response = await fetch(`/api/competition-round/competition/${competitionId}`)
							if (!response.ok) {
								throw new Error(`HTTP error! status: ${response.status}`)
							}
							const json = await response.json()
							this.$nextTick(() => {
								this.competitionModalRounds = json
							})
						} catch (error) {
							// eslint-disable-next-line no-console
							console.error('Error fetching rounds:', error)
						} finally {
							this.competitionModalRoundsLoading = false
						}
					},
					handleAddRoundClick() {
						try {
								const roundsUpdatePayload = this.competitionModalRounds.map(round => ({
										...round,
										// NOTE: reverting eventId association requires us to save it as
										// a fake eventId, because round update database schema requires it
										...(this.competitionModalRoundSelections.includes(round.roundNumber.toString()) ? {
											eventId: this.competitionModalEventSelection.id
										} : {eventId: this.emptyRoundEventId})
									})
								);

								// Update local state
								if (this.formData.event.id === this.competitionModalEventSelection.id) {
										// Preserve existing event data
										this.formData.event = {
												...this.formData.event,
												competitionConfigId: this.competitionModalCompetitionSelection,
												competitionRounds: roundsUpdatePayload
										};
								} else {
										// Check children events
										const childIndex = this.formData.eventChildren.findIndex(child =>
												child.id === this.competitionModalEventSelection.id
										);
										if (childIndex !== -1) {
												// Preserve existing child event data
												this.formData.eventChildren[childIndex] = {
														...this.formData.eventChildren[childIndex],
														competitionConfigId: this.competitionModalCompetitionSelection,
														competitionRounds: roundsUpdatePayload
												};
										}
								}

								// Store pending updates
								this.formData.pendingRoundUpdates = roundsUpdatePayload;

								// Update other events' rounds
								const allEvents = [this.formData.event, ...Object.values(this.formData.eventChildren)];
								roundsUpdatePayload.forEach(round => {
										const events = allEvents.filter(event =>
												event?.competitionRounds?.find(r => r.roundNumber === round.roundNumber)
										);
										if (events.length > 0) {
												events.forEach(event => {
														if (round.eventId !== event.id) {
																event.competitionRounds = event.competitionRounds.filter(
																		r => r.roundNumber !== round.roundNumber
																);
														}
												});
										}
								});

								this.$nextTick(() => {
										window.dispatchEvent(new CustomEvent('child-content-changed'));
								});
						} catch (error) {
								// eslint-disable-next-line no-console
								console.error('Error preparing rounds:', error);
						} finally {
								document.getElementById('add-competition-modal').close();
								this.competitionModalEventSelection = null;
								this.competitionModalCompetitionSelection = null;
								this.competitionModalRounds = [];
								this.competitionModalRoundSelections = [];
						}
					},
					handleRemoveCompetitionRoundFromEvent(competitionRound) {
						this.formData.pendingRoundUpdates = this.formData.pendingRoundUpdates.filter(round => round.id !== competitionRound.id)
						this.formData.pendingRoundUpdates.push({
							...competitionRound,
							eventId: this.emptyRoundEventId
						})

						this.$nextTick(() => {
							window.dispatchEvent(new CustomEvent('child-content-changed'));
						})
					},

					async handlePublishClick() {
						this.saveReqInFlight = true
						const _parentEvent = JSON.parse(JSON.stringify(this.transformEventToPayload(this.formData.event)))
						this.purchasables = this.purchasables.map(p => ({
							...p,
							currency: this.formData.event.currency,
						}))
						// NOTE: never set the eventSourceId on the parent event, it IS the parent
						delete _parentEvent.eventSourceId
						delete _parentEvent.competitionRounds

						let payload = {
							events: [{
								..._parentEvent,
							}],
							purchasableUpdate: {
								event_id: this.formData.event.id,
								...(this.purchasablesCreatedAt !== '' ? {created_at: this.purchasablesCreatedAt} : {}),
								purchasable_items: this.purchasables.map(p => ({
									...p,
									expires_on: p.expires_on ? p.expires_on + this.timeZuluSuffix : null,
									cost: (p.cost * 100),
									inventory: p.inventory,
								})),
							},
							registrationFieldsUpdate: {
								...(this.registrationFieldsCreatedAt !== '' ? {created_at: this.registrationFieldsCreatedAt} : {}),
								fields: this.registrationFields,
							},
							rounds: this.formData.pendingRoundUpdates || [],
						}
						if (this.formData.eventChildren.length > 0 && this.isEventSeries) {
							this.formData.eventChildren.forEach(child => {
								// NOTE: this is importantly set to null to
								// prevent the payload from violaiting request
								// body size limit constraints. The API will
								// always take the parent event's description
								// and seed it to each child event
								const _childEvent = JSON.parse(JSON.stringify(child))

								delete _parentEvent.description
								delete _childEvent.description

								delete _childEvent.competitionRounds
								// NOTE: never override the child event's id with the parent id
								delete _parentEvent.id
								const _mergedEvent = {..._parentEvent, ..._childEvent}
								payload.events.push({
									..._mergedEvent,
									eventSourceId: this.formData.event.id,
									eventSourceType: this.deriveEventSourceTypeFromDropdown(_mergedEvent, this.publishStatus, this.isEventSeries, true),
									startTime: child.startTime ? child.startTime + this.timeZuluSuffix : null,
									endTime: child.endTime ? child.endTime + this.timeZuluSuffix : null,
									// eventSourceType: this.isEventSeries ? this.eventTypeSeriesChildConstant : this.eventTypeSingleConstant,
								})
							})
						}

						try {
							const response = await fetch(`/api/event-reg-purch/${this.formData.event.id}`, {
								method: 'PUT',
								headers: {
									'Content-Type': 'application/json',
								},
								body: JSON.stringify(payload),
							});
							const json = await response.json()
							if (json.status === 'success') {
								this.saveReqInFlight = false
								this.showToast = true;
								this.toastContent = {
									type: 'success',
									message: 'Event updated successfully',
								}
								// NOTE: this API path should come from a data-* attribute
								// that uses the `SitePages` constant for this API path
								const newUrl = `/admin/event/${json.data.parentEvent._id}/edit`;
								window.history.pushState({ path: newUrl }, '', newUrl);
								this.formData.event.id = json.data.parentEvent._id
							} else {
								throw new Error(`Failed to update event ${ json?.error?.message ? ": " + json.error.message : ''}`)
							}
						} catch (error) {
							// eslint-disable-next-line no-console
							console.error('Failed to update event:', error);
							this.saveReqInFlight = false
							this.showToast = true;
							this.toastContent = {
								type: 'error',
								message: error,
							}
						}
					}
				}
			}
	</script>
	}
}
